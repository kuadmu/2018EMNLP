a system for keyword search on data graphs is demonstrated on two challenging datasets: the large dblp and mondial. the system supports search, exploration and question answering. the demonstration shows how the system copes with the main challenges in keywords search on data graphs. in particular, the system generates answers efficiently and completely. it has an effective ranking mechanism that also takes into account redundancies among answers. finally, the system uses a novel technique for displaying multi node subtrees in a compact graphical form that facilitates quick and easy understanding, which is essential for effective browsing of the answers. keyword search over databases is indispensable when we want to quickly pose a focused query. permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro. or commercial advantage and that copies bear this notice and the full citation on the rst page. to copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci. entities without rst studying the schema, or when the database has chunks of text. if properly designed and implemented, it could also be an important tool for data exploration, namely, a mechanism for nding the semantically di erent ways in which the keywords are interconnected. thirdly, we would like to use it for question answering. our demonstration shows how to cope with these three tasks, namely, keyword search, data exploration, and question answering. in particular, we have developed methods for dealing with the main challenges in building an. cient implementation of an algorithm for enumerating answers. the demonstration also employs a novel approach for displaying answers so that they are easily understood. in addition, it illustrates how to deal with redundant answers. the core of any search engine is the algorithm for enumerating answers. when the underlying domain is a database, there are two approaches. in one, candidate expressions are extracted from the schema and evaluated. in the second approach, the algorithm operates directly on a graph representation of the data. the advantage of the rst approach is the ability to use the query processor of the database. the disadvantages are that many expressions could have empty results, and the algorithm can rank only according to a function on the expressions, but not on individual answers. the second approach may potentially overcome these disadvantages. in, we have developed an enumeration algorithm that follows the second approach and is based on the techniques of. this algorithm can handle any database, and in addition, it provably has the following three important properties. cient, namely, answers are enumerated with polynomial delay. second, it generates answers according to an initial ranking. third, it is complete, that is, it can generate all the answers the initial implementation was based on the algorithm of. in later stages, the system has evolved by incorporating optimizations as well as new techniques in order to improve the actual running time. we demonstrate the robustness of our system on two chal the algorithm of operates only on trees. as shown in, achieving completeness is not straightforward. one is the large dblp, which we further enhanced with abstracts of some articles. the second is mondial, which is highly cyclic and has a complex schema. quite often di erent answers to the same query have a common part, whereas the user may be interested in seeing results that are as di erent from one another as possible. our system implements the techniques of for handling this problem, and also allows the user to mark manually some of the displayed answers, thereby excluding similar results. many parameters can be set by the user. controlling these parameters enables the user to see the. ect on the search results and facilitates exploration, rather than just search of the data. lastly, we have developed a novel approach to displaying answers so that they are easily and quickly understood. we discuss it in length in section #. the exquex system of is intended for assisting users in the task of posing queries over xml documents. its goal is to facilitate quick formulation of queries without any advance knowledge of the schema and without being hindered by the complex syntax of a query language. thus, exquex is suitable for answering queries; for example, list all the countries and their capital cities. the system described in this paper is intended for keyword search; for example, it can nd how the keywords france and paris are related. although the two systems have some similarities, they are mostly based on di erent techniques and serve complementary rather than overlapping purposes. with regard to keyword search systems for structured data, research during the past decade has largely focused on performance. researchers have validated their work using ad hoc experiments that may not reflect real world workloads. we illustrate the wide deviation in existing evaluations and present an evaluation framework designed to validate the next decade of research in this field. our comparison of state of the art keyword search systems contradicts the retrieval effectiveness purported by existing evaluations and reinforces the need for standardized evaluation. our results also suggest that there remains considerable room for improvement in this field. given that existing databases are considerably larger than this threshold, our results motivate the creation of new algorithms and indexing techniques that scale to meet both current and future workloads. we found that many techniques cannot scale to even moderately sized datasets that contain roughly a million tuples. or commercial advantage and that copies bear this notice and the full citation on the rst page. one potential barrier to deploying these systems is the ad hoc evaluations performed by researchers. singhal states, a system for experimentation coupled with good evaluation methodology allowed rapid progress in the eld and paved way for many critical developments. ectiveness doubled within six years of its inception. the initiative for the evaluation of xml retrieval workshop established standardized evaluation procedures for xml retrieval. perhaps researchers see evaluation forums such as inex as too expensive to validate experimental system designs, but standardized evaluation is essential for real progress. the strategic step of creating a db ir evaluation forum has yet to occur. without it, progress will not match that of the larger ir community. in the interim, the community should coalesce behind a standardized set of datasets and queries for evaluating search systems we describe such a framework in this paper. according to chen et al, contributions from the research community are highly demanded for developing comprehensive frameworks for evaluating the retrieval and ranking strategies of keyword search on various structured data models. ectiveness and performance of di erent search techniques. keyword search in structured data the ubiquitous search textbox has transformed the way people interact with information. despite the wide ranging success of internet search engines in making information accessible, searching structured data remains a challenge. for instance, the correct granularity of search results must be reconsidered. logical views form relevant search results that present related information as a uni ed whole. identifying relevant results is further complicated due to the fact that the dataphysical representation often does not match a logical view of the information. the explosive growth of social networking and microblogging websites contributes to the ever increasing amount of data stored relationally. we also present details regarding the evaluations of these systems published at top research venues. our survey exposes the ad hoc techniques currently being used by researchers and a lack of experimental repeatability given the scanty details provided in the literature. webber independently considers many of these details and arrives at similar conclusions. in contrast to many previous evaluations, our evaluation framework covers dramatically di erent datasets and contains information needs for each dataset. to promote standardized evaluation, we will make our datasets, queries, and relevance assessments available for other researchers to use in their own experiments. we evaluate state of the art systems in section # using our framework. our results do not support the claimed effectiveness of existing search techniques. we highlight some of the ranking factors that work particularly well for our datasets and query workloads and also present our conclusions regarding state of the art keyword search systems for structured data. numerous researchers have proposed keyword search strategies for structured data, which includes semistructured documents and information stored in relational databases. this push re ects internet users increasing reliance on keyword search and also re ects a desire to hide underlying data representations and to eliminate permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro. to copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci. weaver university of virginia charlottesville, va weaver cs virginia edu complex query languages from end users. to the best of our knowledge, none of these proposed systems has reached mainstream use. the history of the information retrieval community illustrates the importance of standardized evaluation. the text retreival conference testi es to the impact of standardized evaluation, for search. despite the similarity of keyword search in semi structured data and relational data, relational keyword search systems have not been evaluated at this venue. our evaluation framework enables direct comparison of the. in the remainder of this section, we illustrate the di culties inherent to searching structured data and also present the contributions of this work. both semi structured and relational data introduce challenges not encountered in unstructured ir. an xml document might contain a single element that is pertinent to a given query along with many unrelated elements. the digital bibliography library project keyword search over data graphs generalizes both. physical views logical views person character person person. character id name id name person name person name character name ford, harrison indiana jones ford, harrison ford, harrison indiana jones connery, sean professor henry jones connery, sean connery, sean professor henry jones movie. movie id title character name raiders of the lost ark person name movie title indiana jones and the last crusade indiana jones cast ford, harrison raiders of the lost ark personid characterid movieid ford, harrison indiana jones indiana jones and the last crusade connery, sean professor henry jones indiana jones and the last crusade figure #: physical and logical views of relational data. physical views are actual database relations while logical views of the information are not. xml dump currently contains more than million publications; searching this repository for a particular paper should return only the information about that paper and not the complete bibliography. for example, relational data is normalized to eliminate redundancy. the schema separates logically connected information, and foreign keys identify related rows. whenever search queries cross these relationships, the data must be mapped back to a logical view to provide meaningful search results. as shown in figure #, answering the question who played professor henry jones in indiana jones and the last crusade requires data from all physical relations and is answered by the bottommost logical view. recombining disparate pieces of data into a uni ed whole makes searching structured data signi cantly more complex than searching unstructured text. in unstructured ir, each document may be indexed prior to searches. in contrast, indexing all the possible logical views of structured data results in an explosion in the size of the index because the number of possible views is limited only by the data itself. for example, su and widom indexed a subset of the logical views over a database and found that the index exceeded the size of the original data between two and eight times. searching structured data continues to grow in importance as websites serve increasing amounts of data on demand in response to user actions and to personalize webpages. this information is normally stored in a relational database, and bergman estimates that data to be orders of magnitude larger than the static web. novel search techniques are required to access this information ef ciently and. http: dblp uni trier de contributions and outline the major contributions of this paper are threefold. section # reviews related work, providing a high level overview of keyword search systems for structured data. our framework carefully considers the unique requirements of keyword search systems for structured data and follows the traditional de nitions of relevance developed by the ir community. in fact, our results indicate that many strategies perform comparably with regard to search. ectiveness despite contrary claims appearing in the literature. our work is also the rst to investigate the correlation among the results produced by each system to determine if faster query processing techniques produce results comparable to more. keyword search in structured data is an important problem spanning both the database and ir communities. as social networking, microblogging, and other data driven websites store increasing amounts of information in relational databases, users require an effective means for accessing that information. we present structured cover density ranking as an effective means to order search results from keyword search systems that target structured data. structured cover density ranking was designed to adhere to users expectations regarding the ranking of search results namely, results containing all query keywords appear before results containing a subset of the search terms. our evaluation shows that our ranking function provides better results than other state of the art ranking functions across different datasets and distinct information needs. despite the wide ranging success of internet search engines in making information accessible, searching structured data remains a challenge. structured data is typically either semi structured documents or information stored in a relational database. both present signi cant challenges that defy solutions developed for web search. for instance, the correct granularity of search results must be permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro. or commercial advantage and that copies bear this notice and the full citation on the rst page. to copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci. a complete xml document might contain a single element that is pertinent to a given query along with many unrelated elements. the dblp bibliographic databasexml dump contains more than million publications; searching for a particular paper should return only the information about that paper and not the complete bibliography. identifying relevant results is further complicated due to the fact that a physical view of the data often does not match a logical view of the information. for example, relational data is normalized to eliminate redundancy. the schema separates logically connected information, and foreign key relationships identify related rows. whenever search queries cross these relationships, the data must be mapped back to a logical view to provide meaningful search results. as shown in figure #, the information need who played professor henry jones in indiana jones and the last crusade requires data from all four physical relations and is answered by the bottommost logical view. recombining the disparate pieces of data into a uni ed whole makes searching structured data signi cantly more complex than searching unstructured text. for unstructured text, the granularity of search results is de ned to be a single document, and each document may be indexed prior to searches. in contrast, attempting to index all the possible logical views of structured data creates an explosion in the size of the index because the number of possible combinations is limited only by the data itself. for example, su and widom indexed a small portion of the possible logical views of a database and found that the index exceeded the size of the original data between two and eight times. searching structured data continues to grow in importance as modern websites serve increasing amounts of data on demand in response to user actions and to personalize webpages. this data is normally stored in a relational database, and bergman estimates this data to be orders of magnitude larger than the static web. the explosive growth of social networking and microblogging websites contributes to the ever increasing amount of data hidden to traditional search engines. in this paper, we investigate the use of cover density ranking to score structured data search results. clarke et al proposed cover density ranking as an alternative to traditional information retrieval scoring functions. cover density ranking targets short queries and enforces users preferences for coordination matching both are important for internet searches. our evaluation speci cally http: dblp uni trier de addresses the. ciency to be largely an orthogonal issue but show in section # that under and semantics existing query processing algorithms are not asymptotically better than exhaustive search. our contributions are summarized as follows: in contrast to existing ranking techniques described in the literature, we propose ranking results rst by coordination level and then by term co occurrences. our ranking scheme directly follows user expectations regarding the order of search results. we generalize cover density ranking for structured documents. unlike previous work in structured document retrieval, this task is complicated by the uniqueness of cover density ranking, which precludes the use of previous techniques for adapting an unstructured ranking function to handle structured documents. we follow accepted practice in evaluating ir systems. our evaluation includes information needs for each of distinct datasets. we are unaware of any other evaluation reported in the literature that meets this standard. our results contradict the purported effectiveness of previous work, which suggests the need for standardized frameworks to evaluate similar search systems. we show that our ranking scheme is more than twice as. ective as previous work in this eld for the most normalized dataset in our evaluation and also provides modest improvement for other datasets. in the next section, we review related work. section # presents cover density ranking and our generalization that handles structured documents. ectiveness of our ranking scheme in section # and compare it to three other state of the art ranking schemes. therefore, ir style ranking models are crucially needed. the success of knowledge sharing communities like wikipedia and the advances in automatic information extraction from textual and web sources have made it possible to build large knowledge repositories such as dbpedia, freebase, and yago. these collections can be viewed as graphs of entities and relationships and can be represented as a set of subject property object triples in the semantic web data model rdf. queries can be expressed in thec endorsed sparql language or by similarly designed graph pattern search. in this paper, we propose a language model based approach to ranking the results of exact, relaxed and keyword augmented graph pattern queries over rdf graphs such as er graphs. our method estimates a query model and a set of result graph models and ranks results based on their kullback leibler divergence with respect to the query model. we demonstrate the effectiveness of our ranking model by a comprehensive user study. however, exact match query semantics often fall short of satisfying the users needs by returning too many or too few results. woody allen actedinresults woody allen directed hollywood ending. woody allen actedin hollywood ending woody allen directed stardust memories. woody allen actedin stardust memories woody allen directed manhattan. woody allen directedresults query woody allen actedin scoop. woody allen directed scoop woody allen wrote vicky cristina barcelona. woody allen directed vicky cristina barcelona woody allen wrote match point. these repositories typically contain entities such as people, locations, movies, companies, conferences, etc. our main contribution is a novel ranking model based on statistical language models forexact, relaxed, andkeyword augmented queries. they are based on generative probabilistic models for text features in documents. our ranking model, described in section #, constructs lms for the query and for each possible result graph, and ranks the results based on thekullback leibler divergence between the query and result graph lms. building entity relationship graphs has received considerable attention in the recent database, ir, and www literature. for example, information extraction techniques have been successfully applied to textual as well as semi structuredweb sources such as wikipedia, to build large scale knowledge repositories such as dbpedia, freebase, yago, and also communityspeci. and the relationships between them such as bornin, actedin, hasgenre, isceoof, ispcmemberof, and so on. such data conceptually forms a large graph with nodes corresponding to entities and edges denoting relationships, and it can be conveniently represented in the form of subject property object triples of the semantic web data model rdf. when triples are extracted from webpages, they can be associated with a variety of weights, including, extraction con dence, witness count, entity extraction con dence, etc. here rdf is again a convenient way of representing the wealth and diversity of data items such as user groups, friendships, annotations, ratings, etc. in contrast to traditional databases, there is not necessarily a prescriptive schema and the data providers humans strongly prefer a relaxed pay as you go approach. overall, rdf style er graphs nicely capture the entire spectrum from loose collections of data items to curated databases. searching these kinds of data sources enables capturing underlying semantics of the data; a task often dif cult to achieve with traditional web search. entities are enclosed in boxes and the relationships between them are indicated by directed edges. the same graph can beexpressedasasetofrdf triples, asshownintable we refer to an edge of the graph, together with its two nodes, as an er fact or, equivalently, as an spo triple. search on this kind of er rdf data is naturally expressed by means of structured graph pattern queries. based on a syntax similar to that of thec endorsed query language sparql, we can express the query as shown intable. this query consists of triple patterns with variable names starting with a question mark. patterns are combined by a logical conjunction, which is denoted by the dot. a result graph is a subgraph of the underlying knowledge graph which binds the variables and matches the constants in the query. solely using the expressive but boolean match sparql like languages is often too restrictive. users prefer seeing a ranked result list rather than a list of unranked matches. additionally, if the user is interested only in movies set in new york, the query could be augmented with keywords new york to promote, in the ranking, movies such as manhattan and demote movies such as hollywood ending. consider another example query asking for movies by woody allen in which both woody allen and scarlett johansson played roles. as shown in table #, an exact match would yield only one result for this query. but, there are many movies in which woody allen had multiple responsibilities and in which scarlett johansson had a role. for example, scarlett johansson acted in match point which woody allen wrote and directed. this result can be returned only when the original query is relaxed that is, an approximate match to the original query is allowed. these considerations suggest that it is desirable to have an irstyle ranking model for er graph languages like sparql. woody allen directed match point table #: example query and exact and approximate results shouldbe possibletoexpresskeyword conditions together withthe structured predicates of sparql patterns and approximate matches to the query should be allowed. this would be in analogy to prior work on xml ir which has enhanced xpath and xquery by various forms of text search and ranking capabilities. however, in contrast to xml trees, we now need to address the more dif cult setting of graphs and a potentially much higher structural and typing diversity. the latter also distinguishes our scope from prior work on keyword search over relational graphs. in this paper, we investigate triplepattern queriesandshowhowto augmentthemwithkeyword search. this can be seen as the sparql counterpart of xpath fulltext. lms are the state of the art foundation of modern ir and will be explained in section #. our new approach advances such models into the realm of rdf graphs and providesa seamless model forexact, relaxed andkeyword augmented graph structured queries consisting of triple patterns. we conducted a user study on two reallife datasets excerpts of imdb and librarything to show the quality of our search result rankings. the results of our user study are reported in section #. similar kinds of er graphs arise in web settings, for example, in social tagging communities such as librarything. for example, for the queryintable, well knownmovieslike hollywood ending or manhattan should precede less known movies like stardust memories. woody allen actedin manhattan table #: example query and unranked results woody allen actedin. in keyword search over data graphs, an answer is a nonredundant subtree that includes the given keywords. an algorithm for enumerating answers is presented within an architecture that has two main components: an engine that generates a set of candidate answers and a ranker that evaluates their score. to be effective, the engine must have three fundamental properties. it should not miss relevant answers, has to be efficient and must generate the answers in an order that is highly correlated with the desired ranking. it is shown that none of the existing systems has implemented an engine that has all of these properties. in contrast, this paper presents an engine that generates all the answers with provable guarantees. experiments show that the engine performs well in practice. it is also shown how to adapt this engine to queries under the or semantics. in addition, this paper presents a novel approach for implementing rankers destined for eliminating redundancy. essentially, an answer is ranked according to its individual properties and its intersection with the answers that have already been presented to the user. within this approach, experiments with specific rankers are described. in ir, the goal is to nd documents that are relevant to the given keywords. even when applying ir to textual documents in xml format, the goal is similar, namely, to search for relevant fragments rather than whole documents. in other words, the xml elements of a textual document do not constitute a semistructured database, but rather show how to break the document into meaningful fragments of text that may be relevant to the given keywords. in keyword search over databases, the focus is not merely on nding relevant fragments of text, but also on discovering the semantic relationships that hold between the keywords. for example, suppose that we are searching for the keywords jones and compilers in a university database. just looking for occurrences of these keywords wherever they might appear in the database is quite meaningless. instead, we would like to know how jones and compilers are related to each other. for example, we might discover that jones is the teacher of the course named compilers; another answer might be that jones is the author of a book that has the keyword compilers in its title. note that these are two distinct relationships between the given keywords. keyword search in databases is performed over a graph in which nodes are associated with keywords and edges describe semantic relationships. for example, if the database is as an xml document, then it can be naturally represented as a graph. if the database is relational, then the nodes correspond to the tuples and the edges connect pairs of tuples that can be joined by using a foreign key. a search query is formulated merely as a list of keywords and it does not convey any structural information. answers to the query are subtrees that contain occurrences of the given keywords. the tree structure of an answer describes the relationship between the keywords. a system that supports keyword proximity search over complex data graphs faces two main challenges that are evident, for example, in the mondial database which is highly cyclic. the rst is the standard challenge of ir, namely, to nd the most relevant answers. the second, which arises in our type of search and especially in complex data graphs, only a few elements of textual documents, such as author name, can be viewed as objects of a semistructured database. the mondial database contains geographic data and is available at http: www dbis informatik. is to deal with the repeated information problem. that is, a system should not overwhelm the user with repeated information. while the literature contains a lot of research on the rst problem, it ignores the second. the main reason is that past systems have dealt with rather simple data graphs, eg, dblp and imdb. note that related problems are those of novelty and rst story detection in a stream of textual documents. however, these problems face an inherently di erent notion of redundancy, namely, one that is based on similarity and containment of textual data in separate documents. the major obstacle in dealing with the rst challenge is the huge number of answers, ie, subtrees that contain the given keywords. typically, only a small fraction of those answers are deemed relevant by users. the rst step in dealing with this problem is to require an answer to be reduced, which means that every proper subtree has fewer occurrences of the keywords. but even under this de nition, the number of answers can be very large. we have discovered, for example, that when searching the dblp bibliography with names of two researchers who wrote many papers, there are literally tens of thousands of answers that connect the two authors through di erent chains of citations. ranking is used in order to cope with the large number of answers. thus, we actually want to perform keyword proximity search, that is, to nd occurrences that are close to each other in the data graph. consequently, the size of an answer plays a prominent role in the ranking function. ideally, the system should enumerate the answers in ranked order, but it is unlikely that it can be done ef ciently because just nding the smallest answer is intractable. furthermore, it seems impossible to translate practical ranking measures into weights on the nodes and edges of data graphs. to circumvent the above problem, systems for keyword proximity search process queries by means of two components: an engine that generates candidate answers and a ranker that determines a score for each of the generated answers. at any given time, the process may stop and return the topanswers among those that have already been generated. furthermore, the search can be resumed in order to produce more answers if the user wants to see them. in this paper, we present a system that follows this architecture. ectiveness of the above approach is based on the ability of the engine to. ciently generate the answers in an order that is correlated with the ranking measures. in this respect, especially when considering large and complicated graphs, none of the engines used in existing systems is acceptable. for example, the engines of evaluate all possible queries that may connect the given keywords. a large number of these queries may have an empty result, which causes the whole process to be ine cient. furthermore, these engines cannot take weights into account, which leads to a rather limited correlation with the ranking measures. as another example, the engines of may miss highly relevant answers, as we show in section #. therefore, a robust system cannot rely on any of the above engines. ective engine for generating answers must satisfy three conditions. first, it must be able to generate all the answers. second, the answers must be enumerated in an order that is correlated with the nal ranking. ciency is a polynomial bound on the delay between answers. note that none of the implemented engines enumerates with polynomial delay. algorithms that satisfy all of the three conditions are presented in. however, these algorithms do not lend themselves easily to a practical implementation, since they use complex subroutines for approximating steiner trees. in this paper, we describe a search engine that is based on an incremental algorithm for enumerating subtrees in a approximate order by increasing height. this algorithm runs with polynomial delay and can nd all the topanswers. our experiments show that this engine is practical and, furthermore, there is a good correlation between the generated order of answers and the desired order according to the inverse of the weight. after generating the candidate answers, the ranker sorts them according to a more sophisticated ranking function, eg, one that is based on the total weight and additional ir measures. however, this ignores the repeated information problem, ie, the second challenge that we now illustrate. consider again the example of the university database and suppose that the query contains the three keywords jones, compilers and cs. there are many relevant connections between pairs of the keywords, eg, jones teaches compilers, jones wrote a book about compilers, jones is a sta. member of cs, compilers is a course in cs, jones is the head of cs, etc. but then, many combinations of these connections are also relevant answers. hence, a system that is not aware of this problem will overwhelm the user with all the possible combinations, without being able to rank them correctly. our ranker employs a novel technique for eliminating repeated information. the main idea is that the ranking function dynamically adapts itself, during the ranking procedure, to address redundancy. more particularly, after selecting the topanswers, the ranking function penalizes the other answers if they contain information that is similar to what has already been given. we consider several policies for determining the penalty. given the absence of standard benchmarks for this type of search, we devised a novel methodology for evaluating the. ectiveness of methods that deal with the repeated information problem. essentially, we measure the reduction in the redundancy and compare it with the loss in the score. our experiments and evaluation methodology indicate that our approach is. ective in the sense that repeated information can be eliminated with a relatively low drop in the score of the top answers. furthermore, one of the proposed alternatives to determining penalties for repeated information is better than the others. note that methodologies for detecting redundancy have been proposed in the context of xml countries code name capital governmentbelgium bru monarchy nor norway osl monarchy cities code name country population ant antwerp, bru brussels, osl oslo nor, organizations name headq members eu bru esa par members country organizationesaeu nor esa figure #: a small portion of the mondial relational database retrieval. however, it is not clear how their methodologies can be applied in the context of keyword proximity search. for instance, in xml retrieval, redundancy means that both an element and one of its sub elements are retrieved. obviously, the notion of redundancy in keyword proximity search is much more complicated. the rest of the paper is organized as follows. in the next section, we describe the formal setting and the basic architecture of our search engine. in section #, we give the algorithm for enumerating answers with polynomial delay in a approximate order by increasing height. for completeness of the presentation, the underlying basic procedure of our algorithm is described in the appendix. section # describes the repeated information problem and our ranking techniques. the implementation and experimentation are described in section #. in section #, we describe how to adapt our algorithm to enumerating answers that contain some of the given keywords, ie, searching under the or semantics. query processing over graph structured data is enjoying a growing number of applications. a topkeyword search query on a graph finds the topanswers according to some ranking criteria, where each answer is a substructure of the graph containing all query keywords. current techniques for supporting such queries on general graphs suffer from several drawbacks, eg, poor worst case performance, not taking full advantage of indexes, and high memory requirements. to address these problems, we propose blinks, a bi level indexing and query processing scheme for topkeyword search on graphs. blinks follows a search strategy with provable performance bounds, while additionally exploiting a bi level index for pruning and accelerating the search. to reduce the index space, blinks partitions a data graph into blocks: the bi level index stores summary information at the block level to initiate and guide search among blocks, and more detailed information for each block to accelerate search within blocks. our experiments show that blinks offers orders of magnitude performance improvement over existing approaches. keyword queries offer a convenient alternative to traditional sql in querying relational databases with large, often unknown, schemas and instances. the challenge in answering such queries is to discover their intended semantics, construct the sql queries that describe them and used them to retrieve the respective tuples. existing approaches typically rely on indices built a priori on the database content. this seriously limits their applicability if a priori access to the database content is not possible. examples include the on line databases accessed through web interface, or the sources in information integration systems that operate behind wrappers with specific query capabilities. furthermore, existing literature has not studied to its full extend the inter dependencies across the ways the different keywords are mapped into the database values and schema elements. in this work, we describe a novel technique for translating keyword queries into sql based on the munkres algorithm. our approach not only tackles the above two limitations, but it offers significant improvements in the identification of the semantically meaningful sql queries that describe the intended keyword query semantics. we provide details of the technique implementation and an extensive experimental evaluation. the more the relational data complexity is increasing and the user base is shifting towards the less technically skilled, the more the keyword searching is becoming an attractive alternative to traditional sql queries, mainly due to its simplicity. unfortunately, this simplicity comes with the price of inherent ambiguity. thus, the challenge of answering a keyword query over a relational database is to discover the database structures that contain the keywords and explore how these structures are inter connected to form an answer. the discovered structures, alongside their inter connections, are actually representing in relational terms the semantic interpretation of the keyword query. numerous studies and tools can already be found in the scienti. generally, these works consider the database as a network of interconnected tuples, they detect those containing the keywords in the query, they generate connected components based on how these tuples are associated, and they return these connected tuples as an answer to the query. to do so, specialized structures that index the database content are used. by using these indices, they may directly retrieve the tuples of interest, or they may instead construct the queries expressions that retrieve these tuples when evaluated. this is the basic idea followed by the modern commercial database management systems supporting full text search over their relational database. unfortunately, existing techniques suffer from two main limitations. the rst is that they require a priori access to the data instance in order to build the indices that will locate the tuples related to the given keywords at run time. this seriously limits their applicability if such access is not possible. examples of such situations include databases on the hidden web and sources located behind wrappers in data integration systems that typically expose only their schema information and lack noti cation mechanisms for their data updates. the second limitation is that no considerable attention has been paid to the inter dependencies among the query keywords. data structure represent the same semantics as a keyword in a user query does not only depend on the relationship between the keyword and the data structure, but also on the data to which the other keywords in the query are mapped. this is because despite the fact that a keyword query is. at list of keywords, the meaning of each keyword is not independent of the meaning of the others, but they all collectively represent the intended concepts the user had in mind posing the query. furthermore, not all the keywords represent instance values. many are used as meta data speci cation of the adjacent keywords. in this work, we propose a novel technique for answering keyword queries over relational databases. the queries are translated into a number of sql queries that capture the possible semantics of the keyword query. the generated sql queries can be evaluated on the database, and their results serve as the answer to the keyword query. one of the novelties of the technique is that it is not based on an a priori access to the database instances. moreover, our approach exploits the relative positions of the keywords in the query alongside auxiliary external knowledge in order to make a more educated guess of the semantics that most likely represent those of the keyword query, and then rank them accordingly. the strategy can not only be easily incorporated to many relational database management systems, but it can also be used as an enhancement of existing keyword searching techniques that utilize the database instance, offering them signi cant improvements over effectiveness and ef ciency. an advantage of our approach is that it can be used to assist users browsing databases with large unknown schemas. semantics in mind but in an exploratory manner, mainly when they are neither fully aware of the type of information that is stored in a database, nor of the way this information is stored. the possible interpretations of a keyword query according to the schema and domain information of the database will be generated by our approach. in contrast to other keyword searching techniques on relational data that return sets of linked tuples, we can return the interpretations expressed in sql. the study of these queries can reveal tables, attributes and join paths, providing the user with enough information to understand the kind of data that is stored in the database and the way this data is structured. our key contributions are as follows: we formally de ne the problem of keyword querying over relational databases that lack apriori access to the database instance; we introduce the notion of a weight as a measure of the likelihood that the semantics of a keyword are represented by a database structure, ie, a table, an attribute, or a value. we further distinguish the weights to intrinsic and contextual, to emphasize that this likelihood does not depend only on the meaning of the keyword semantics when the keyword is considered in isolation, but also on the way the semantics of the remaining, especially the neighbouring, keywords are represented in the data. we extend and exploit the hungarian algorithm to develop a technique for the systematic computation of the contextual weights that leads into to the generation and ranking of the different interpretations of a keyword query in terms of sql; nally, we experimentally evaluate our approach on real application scenarios. the remainder of the paper is structured as follows: section # provides a motivating example and section # formally de nes the problem. sections provides details on our technical contributions, ie, the computation of the intrinsic weights, the contextualization and the selection of the best mappings. the relationship of our approach to the related work is discussed in section # and section # describes our experimental evaluation and discusses our ndings. finally some conclusions are presented in section #. they include discover, dbxplorer, banks, spark, sqak, and many others. although there are already keyword based approaches on relational data that take into consideration metadata, they provide only partial solutions to the problem, and they only use the metadata as a way to improve their technique. it is often the case that users formulate keyword queries without some speci. this search model is complicated for most ordinary users. with the amount of available text data in relational databases growing rapidly, the need for ordinary users to search such information is dramatically increasing. even though the major rdbmss have provided full text search capabilities, they still require users to have knowledge of the database schemas and use a structured query language to search information. inspired by the big success of information retrieval style keyword search on the web, keyword search in relational databases has recently emerged as a new research topic. the differences between text databases and relational databases result in three new challenges: answers needed by users are not limited to individual tuples, but results assembled from joining tuples from multiple tables are used to form answers in the form of tuple trees. a single score for each answer is needed to estimate its relevance to a given query. these scores are used to rank the most relevant answers as high as possible. relational databases have much richer structures than text databases. existing ir strategies to rank relational outputs are not adequate. in this paper, we propose a novel ir ranking strategy for effective keyword search. we are the first that conducts comprehensive experiments on search effectiveness using a real world database and a set of keyword queries collected by a major search company. experimental results show that our strategy is significantly better than existing strategies. our approach can be used both at the application level and be incorporated into a rdbms to support keyword based search in relational databases. obviously, this model of search is too complicated for ordinary users. with such support, a user can avoid writing a sql query; and he she can just submit a simple keyword query off wall to the lyrics database. first, in text databases, the basic information units searched by users are documents. for a given keyword query, ir systems compute a numeric score for each document and rank the documents by this score. the top ranked documents are returned as answers. note that the query matches both text columns values in the tuple. therefore, there are many tuple trees that can be answers for the query. we need to rank the more relevant answers higher. otherwise, users will be discouraged to use keyword search. for example, some text columns such as peoplenames and album titles are very short, while other text columns such as song lyrics are much longer. third, relational databases have much richer structures than text databases. the scores should be defined in such a way so that the most relevant answers are ranked as high as possible. in a database that contains a large amount of text data, these strategies will be shown not to work well. they consider each text column as a collection and each value in the text column as a document. a state of the art ir ranking method is used to compute a score between a given query and each text column value in the tuple tree. in addition, our experimental results show that their strategy ignores some important factors that are critical for search effectiveness. the amount of available structured data for ordinary users grows rapidly. besides data types such as number, date and time, structured databases usually also contain a large amount of text data, such as names of people, organizations and products, titles of books, songs and movies, street addresses, descriptions or reviews of products, contents of papers, and lyrics of songs, etc. the need for ordinary users to find information from text in these databases is dramatically increasing. the objective of this paper is to provide effective search of text information in relational databases. we take a lyrics database as an example to illustrate the problem. there are five tables in the lyrics database. table song has two text columns: title and lyrics. the tuples of table artist and those of table album have:relationships, and table aritst album is the corresponding relationship table. table song album is also a relationship table capturing the:relationships between tuples of album and song. note that table aritst album and table aritst album do not have other columns except their primary keys and foreign keys. artist artist album artistid name a a eminem a code red a jojo album albumid title world off the wall jojo album song song songid title lyrics how come how come we donby. leave ive been waiting all day figure #: lyrics database example the traditional search model in relational databases requires users to have knowledge of the database schema and to use a structured query language such as sql or qbe based interfaces. even though most of the major rdbmss have integrated full text search capabilities using relevance based ranking strategies developed in information retrieval, they still have the above two requirements for users. suppose a user is looking for albums titled off the wall and he she cannot remember the exact title. a typical sql query is shown in figure # and the tuple is expected to be one of the top ranked results. select from albumwhere contains order by score desc figure #: an oracle sql example query: off wall query: lyrics how come by query: album by and eminem tuple tree: tuple tree: a. a figure #: queries and tuple trees with the tremendous success of web search engines, keyword search has become the most popular search model for ordinary users. users do not need to know the database schema or use a structured query language. instead, they submit a list of keywords using a very simple interface, and a search engine returns ranked documents based on relevance to the query from its text databases. therefore, it is extremely desirable to support the keyword search model in relational databases. applying the keyword search techniques in text databases to relational databases is a challenging task because the two types of databases are different. in relational databases, however, information is stored in the form of columns, tables and primary key to foreign key relationships. the logical unit of answers needed by users is not limited to an individual column value or even an individual tuple; it may be multiple tuples joined together. note that, in figure #, an edge from a to ab denotes a primary key to foreign key relationship. for query, one desired answer is a joining tree of five tuples. for query, one desired answer is a joining tree of five tuples. second, effectiveness is a key factor for the success of keyword search. even in a medium sized database, there may be dozens of candidate answers for an ordinary keyword query. there exists many titles of songs, titles of albums or lyrics of songs that contain both keywords off and wall. however, these answers are not equally useful to the user. note that a key reason behind the tremendous success of web search engines is that their ranking strategies are highly effective that, for many queries, they can rank relevant web pages in the first ten results out of billions of web pages. due to the difference in the basic answer unit between document searches and database searches, in relational databases, we need to assign a single ranking score for each tuple tree, which may consist of multiple tuples with text columns, in order to rank the answers effectively. the characteristics of text columns are usually diverse. in contrast, in text databases, we only need to compute a score for each single document. thus, the ranking strategy for relational databases needs to consider more factors and is more complicated. for a given query, we desire answers to be returned with semantics. for example, for query and one answer tuple tree, it is quite obvious that the subquery how come is the song title of the tuple, and the subquery is the artist name of the tuple a, although all individual keywords in the two queries are very common words, and some individual keywords also appear in other text values of tuple tree. we consider the correspondences between sub queries in a given query and database columns in an answer as the semantics of the query in the answer. in summary, in relational databases, we have three key steps for processing a given keyword query. generate all candidate answers, each of which is a tuple tree by joining tuples from multiple tables. then compute a single score for each answer. recently, keyword search on relational databases has merged. dbxplorer, discover, banks, and hristidis et al are systems that support keyword search on relational databases. for the first step, they generate tuple trees from multiple tables as answers. the first three systems require an answer containing all keywords in a query, while the last one only requires an answer containing some but not necessarily all keywords in the query. efficiency has been the focus for the first step: rules are designed to avoid generation of unnecessary tuple trees, and more efficient algorithms are proposed to improve the time and space complexities. for the second step, the first two systems use a very simple ranking strategy: the answers are ranked in ascending order of the number of joins involved in the tuple trees. when two tuple trees have the same number of joins, their ranks are determined arbitrarily. thus, all tuple trees consisting of a single tuple are ranked ahead of all tuples trees with joins. the ranking strategy of the banks system is to combine two types of information in a tuple tree to compute a score for ranking: a weight of each tuple, and a weight of each edge in the tuple tree that measures how related the two tuples are. the strategy of dbxplorer and discover and the strategy of banks for the second step do not utilize any state of the art ir ranking methods, which have been tremendously successful. hristidis et al propose a strategy by applying ir style ranking methods into the computation of ranking scores in a straightforward manner. a final score is obtained by dividing the sum of all these scores by the number of tuples in the tree. however, they only concentrate on the efficiency issue of the implementation of the ranking strategy and do not conduct any experiments on the effectiveness issue. we propose a novel ranking strategy that ranks answers effectively and returns answers with basic semantics. this strategy can be used both at the application level and be incorporated into a rdbms to support keyword search in relational databases. we adapt the framework proposed in hristidis et al to generate tuple trees as answers for a given query. efficiency issues are not investigated in this paper. we emphasize that effectiveness of keyword search of text data is at least as important as efficiency. our key contributions are as follows: we identify four new factors that are critical to the problem of search effectiveness in relational databases. we present avatar semantic search, a prototype search engine that exploits annotations in the context of classical keyword search. the process of annotations is accomplished offline by using high precision information extraction techniques to extract facts, con cepts, and relationships from text. these facts and concepts are represented and indexed in a structured data store. at runtime, keyword queries are interpreted in the context of these extracted facts and converted into one or more precise queries over the structured store. in this demonstration we describe the overall architecture of the avatar semantic search engine. we also demonstrate the superiority of the avatar approach over traditional keyword search engines using enron email data set and a blog corpus. the eld of text analytics provides a rich suite of techniques to automatically analyze and extract structured information from text. annotations extracted in this fashion range from lowlevel linguistic features to higher level concepts such as persons, organizations, and locations. the use of such annotations in querybased retrieval has become an active area of research. we motivate this approach using the following example involving keyword search over a corpus of email messages. it is clear that for user, document in figure # is relevant whereas document is not. or commercial advantage and that copies bear this notice and the full citation on the rst page. to copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci. while the use of annotations for the latter have been considered before, in avatar semantic search, annotations are used to account for both factors. to extract semantics from document content, avatar semantic search executes a variety of annotators of ine and stores the resulting annotations in a structured data store called the annotation store. each oval in the gure represents a concept or relationship that has been extracted by analyzing email messages for instance, using appropriate text analysis techniques, the text segment year# in document can be recognized as an instance of a phonenumber, tom shelton can be tagged as an instance of the concept author, and these two instances can be linked via the relationship authorphone. given these annotations, the following query, in oql like syntax, captures the intent of user: query. selectfrom authorphone ap, emailwhereap doc and match as this example shows structured queries over concepts and rela tionships, extracted as annotations, provides a powerful mechanism for representing user intent. there are two parts to the avatar semantic search engine: extraction and representation avatar semantic search uses the publicly available uima framework to compose and execute text analysis programs. the uima framework allows us to de ne a document processing work ow consisting of a chain of annotators. documents are fed in at one end of the work ow and the resulting annotations become available at the other end. the annotations produced through this process are persisted in an annotation store. while the task of building annotators and persisting annotations involves several challenges, the details are not relevant for this demonstration proposal. the authorphone relationship associates the author of an email with his her phone number mentioned in the body. he is an excellent source and has acan be reached at. long, sordid histroy in california steve kean, you may want to mention energy market. this figure #: two documents from the enron email collection signature email url email address url company phone person authorphone organization author personphone phone flightinfo person phone author person phonenumber logininfo contactinfo directions instructions email introduction usaddress meeting conferencecall acronym schedule figure #: schema for annotation store for email produces a set of documents as result. describe avatar semantic searchrun time architecture and the steps involved in keyword query interpretation. in this demonstration we present avatar semantic search, a prototype search engine that exploits annotations in the context of classical keyword search. avatar semantic search uses annotations to explicitly model the user intent underlying a keyword query. suppose a user who submits this query had the following intent in mind: retrieve emails from tom that mention his phone number. alternately, for a different user who submits the same keyword query but with the intent retrieve emails sent by tom that mention a phonenumber both documents in figure # are relevant. as this example illustrates, the relevance of a document to a keyword query depends on two factors: the precise intent of the user submitting the query and the semantics of the document permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro. figure # is an example schema for such an annotation store. we have implemented the annotation store as a thin layer on top of a commercial dbms. our primary focus will be the task of bridging the gap between the keyword queries that users submit and the structured queries that model their intent. avatar semantic search uses the notion of keyword query interpretation a process by which end user keyword queries are automatically converted into one or more precise queries called interpretations. each interpretation, when executed over the annotation store, for clarity, atomic attributes of each concept are listed below the concept in parenthesis. document document from: tom shelton from: tom briggs. please call me if you have any call jeff dasovich at. in the rest of the paper, we brie. in this paper, we study the effectiveness and the efficiency issues of answering topkeyword query in relational database systems. we propose a new ranking formula by adapting existing ir techniques based on a natural notion of virtual document. compared with previous approaches, our new ranking method is simple yet effective, and agrees with human perceptions. the experimental results demonstrate significant improvement to the alternative approaches in terms of retrieval effectiveness and efficiency. with the increasing amount of text data stored in relational databases, there is a demand for rdbms to support keyword queries over text data. as a search result is often assembled from multiple relational tables, traditional ir style ranking and query evaluation methods cannot be applied directly. we also study efficient query processing methods for the new ranking method, and propose algorithms that have minimal accesses to the database. we have conducted extensive experiments on large scale real databases using two popular rdbmss. we show how expressions in our proposed language can be rewritten using the vocabulary of the web extracted kb, and how different possible rewritings can be ranked based on their syntactic relationship to the keywords in the query as well as their semantic coherence in the underlying kb. an extensive experimental study demonstrates the efficiency and effectiveness of our approach. in this system, the rewritten query describes an arbitrary topic of interest for which corresponding entities, and documents relevant to the entities, are efficiently retrieved. automated extraction of structured data from web sources often leads to large heterogeneous knowledge bases, with data and schema items numbering in the hundreds of thousands or millions. formulating information needs with conventional structured query languages is difficult due to the sheer size of schema information available to the user. we address this challenge by proposing a new query language that blends keyword search with structured query processing over large information graphs with rich semantics. our formalism for structured queries based on keywords combines the flexibility of keyword search with the expressiveness of structures queries. we propose a solution to the resulting disambiguation problem caused by introducing keywords as primitives in a structured query language. additionally, we show how our query language fits into quick, an end to end information system that integrates web extracted data graphs with full text search. the world wide web hoards massive amounts of unstructured text data. orts to extract structured data sets from unstructured and semi structured web documents, such as exdb, yago, and webtables, have resulted in the creation of massive knowledge bases: structured data sets often encoding rich schematic information over millions of entities. users can no longer express desired structure in the query, and can no longer explicitly take advantage of schema information. german has won nobel award this query searches for all data items with a syntactic occurrence of the given keywords. in particular, the query will nd data items that are german, rather than those which contain the keyword german. the advantage of this approach is in the exibility of how queries can be expressed. this phenomena, known as polysemy, is just one of the challenges of disambiguation. our query language allows a natural keyword based description of entity relationship queries over large knowledge bases without intimate background knowledge of the underlying schema. section # surveys and compares related work with our approach and section # concludes. the user may pose the following conjunctive query to an information system. we propose a model for keyword based structured queries that allows users to create expressive descriptions of their information need without having detailed knowledge of the underlying schema. at this scale, writing structured queries can be a daunting task as the sheer magnitude of the information available to express the query is overwhelming. to deal with this problem, and also open a new form of exploratory search, recent work has brought keyword query processing to structured data models, such as keyword search over relational databases. as an example, consider a user who wants to nd all people of german nationality who have won a nobel award. there are two important differences between the structured query and the keyword variant. second, the keyword query will look for data items with any syntactic occurrence of nobel award, while the structured query uses this as a selection condition over the qualifying entities, exploiting the structure of the query to nd qualifying results. german language nobel prize hasweight german people, award: haswonprize: german alphabet turing award figure #: an ambiguous conjunctive query and the possible interpretations. on one end of the spectrum, structured query languages, such as sql, provide a mechanism to express complex information needs over a schema. a user of such a language must have intimate knowledge of the underlying schema in order to formulate well formed queries for arbitrary information needs. these languages allow users to express information needs with little to no knowledge of any schematic constructs in the underlying information system, giving ease of use as well as useful exploratory functionality to the user. consider the design of a query language that falls somewhere in the middle of this spectrum. in this setting the query from the previous example may be written using structure as in, but with keywords as in. german, has won this approach keeps the exibility of keywords, but allows structure using conjunctions and nesting with relations. at the same time, the query retains explicit structure that gives greatly increased expressiveness over at keyword queries. the problem with this approach is that the number of possible queries is exponential in the size of the query. this is problematic as many of the possible matchings may be meaningless with respect to the underlying schema, or may not represent the users actual intention. processing every possible match is not only ine cient, as many of the possible query interpretations may have empty result sets, it can overload the user with many unwanted results from unintended interpretations. in this paper, we investigate a solution to the problem of querying over rich massive schemas by introducing a structured query language that builds upon keywords as its most basic operator, while taking disambiguation steps before query evaluation in order to avoid the exponential blow up caused by keyword ambiguity. we analyze the consequences of introducing ambiguity into a structured query language, and propose a model for. we show how to accommodate incomplete knowledge in the underlying kb by allowing query terms to be used as keywords during document retrieval, integrating full text search in the cases where full disambiguation can not be achieved. lastly, we show how our proposed query processing model can be integrated into quick an end to end semantic search system. we demonstrate the viability of our proposed approach with an extensive experimental evaluation of both the quality and performance of a prototype implementation of the complete system. outline the remainder of the paper is organized as follows. section # reviews relevant background information and gives an overview of our problem and proposed architecture. in section # we show experimental results of a prototype implementation. as an example, both exdb and yago have schema items numbering in the millions, and fact collections numbering in the hundreds and tens of millions respectfully. webtables has over ve million unique attribute names in over two million unique relational schemas. while this alleviates the information overload problem caused by massive schemas, it comes at a loss of expressivity. german people, haswonprize, nobel prize if the user is not familiar with the schema of the underlying information system, then they may alternatively issue the following keyword query. first, the structured query will be processed by making use of explicit semantics encoded as an internal schema. the rst and third predicates are an example of matching on keyword occurrence, while the second predicate is an example of matching on edit distance. this example illustrates how query languages can vary in their expressiveness and ease of use. on the other end of the spectrum are free form query languages such as keyword queries. we would ideally like to retain the expressive structure of structured queries, while incorporating the exibility of keyword queries. one way to achieve this is to embed ambiguity into the structured query language by allowing keywords or regular expressions to take the place of entities or relations. in this model each keyword phrase will be replaced, by the query processor, with a set of candidate schema items based on some metric of syntactic matching, such as keyword occurrence or edit distance as depicted in figure #. users need not have intimate knowledge of the underlying schema to formulate queries as is necessary with traditional structured query languages. for example, the query for all german people who have won an award will produce many results that obstruct the user from nding those of interest. note that syntactic matching alone could not possibly be su cient as a disambiguation solution in all cases, as the keyword german is a natural choice to express both a nationality and a language. contributions in this work, we make the following contributions. section # presents our structured keyword query language, with the disambiguation problem explored in section #. language modeling approaches to information retrieval are attractive and promising because they connect the problem of retrieval with that of language model estimation, which has been studied extensively in other application areas such as speech recognition. the basic idea of these approaches is to estimate a language model for each document, and then rank documents by the likelihood of the query according to the estimated language model. a core problem in language model estimation is smoothing, which adjusts the maximum likelihood estimator so as to correct the inaccuracy due to data sparseness. in this paper, we study the problem of language model smoothing and its influence on retrieval performance. we examine the sensitivity of retrieval performance to the smoothing parameters and compare several popular smoothing methods on different test collections.