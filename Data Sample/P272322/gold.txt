survey a wide range of related work on the evaluation of alias analysis and alias control. previous studies of alias analysis on large programs either statically compare the precision of several pointer analyses or use dynamic analysis to evaluate the precision of pointer analyses. among the dynamic analysis studies, mock et al. nd that several context insensitive analyses heavily over approximate the points to sets observed during a typical run, while liang et al. nd that, for java programs, context insensitive analyses handle most allocation sites and programs very well, but are very imprecise for others. another study directly compares context sensitive and context insensitive points to analysis for java and con rms that context sensitivity is much more precise in the sense that each individual context has very few points to relationships compared to the ow insensitive analysis summary over all contexts. such empirical comparisons of pointer analyses are critical to evaluate the. however, the metrics used, generally points to set sizes and related properties such as side. ect sizes or value liveness, are not useful for understanding how aliasing is used. earlier studies of aliasing structure focus on heap shape properties and look at smaller programs. ow insensitive intraprocedural core on which a context or object sensitive analysis is built. our ow and path sensitive intraprocedural analysis is di erent, harking back to early work on aliasing; for example, landi and ryder introduced labels for naming access paths fteen years ago. ow, path, and contextsensitive analysis, showing good results for programs up to, loc; unfortunately, this system is not available and we were unable to perform an empirical comparison. our technique for object naming is more general than previous work, which typically selectively inlines a few allocation functions to generate more allocation points. our object naming scheme achieves bene ts roughly similar to unlimited ob ject sensitivity in ob jectoriented languages, because object sensitivity focuses on providing distinctions associated with data based on allocation site rather than context sensitivity, which provides distinctions based on calling context. some common characteristics of program aliasing behavior have been exploited by previous pointer analyses. das uses the fact that pointers are commonly used for passing addresses of stack ob jects in. nd that many locks are restricted: while multiple aliases may exist, only one is used within a scope, allowing precise ow sensitive analysis. our study shows that almost all values are used in this same restricted fashion. several previous points to analyses are summary based. liang and harrold separate local and global pointers to achieve a summary based alias analysis that scales well, but is also uni cation based and ow insensitive. some previous context sensitive approaches use a similar summary to ours with similar issues. for more expressive approaches the summaries appear to grow excessively large for large programs; we avoid this problem by exploiting heap invariants to compactly represent global information and simplify summaries. alias control techniques specify the presence or absence of aliasing in programs. uniqueness based techniques describe how and where pointers are unaliased. we believe the linear nature of unique pointers imposes unnecessary restrictions: it is common to copy data and have both values be live, though in separate scopes. ahndrich and deline allow aliasing on linear values by restricting how the aliases are used. ownership based techniques constrain the possible aliases of a pointer. early ownership techniques include hoggislands, which restrict external aliases to the entire contents of particular objects. later work has made ownership systems more exible by having multiple ownership domains for the contents of an object and adding access permissions between separate domains. aldrich et al introduce aliasjava, which adds both uniqueness and ownership annotations to document aliasing behavior in java. while uniqueness allows aliasjava to cleanly describe unaliased pointers, we believe the mechanisms. ered by ownership are insu cient to accurately describe actual aliasing. aliased pointers are either owned, and may be aliased with any other pointer with the same owner, or are shared and may be aliased with any pointer. in contrast, the annotations used and constraints generated by our analysis directly specify the targets of aliased pointers, correlating closely to runtime aliasing behavior without imposing signi cant documentation overhead.