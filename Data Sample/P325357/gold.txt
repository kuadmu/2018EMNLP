problem statement in a multiprocessor execution, memory accesses from different processors form a dependence graph. the record phase dynamically constructs and logs the graph, and the replay phase uses the logs to reproduce the same execution. the efforts in designingr schemes have been focusing on recording data races. it is further complicated by relaxed consistency and non atomic writes. figure # shows one of the valid sc interleavings of the accesses from three processors in figure #. an scv is a cycle among some accesses in the dependence graph. cache coherence does not imply write atomicity, because it only guarantees the serialization of accesses to the same location but says nothing about when the values are visible. note that this cycle involves the same set of accesses as the case in figure #, but if the system ensures write atomicity, the scv cannot happen. in summary, non atomic writes can cause additional scvs that do not exist assuming write atomicity. r sc execution early point to point approaches record memory races when threads do communicate, incurring large logs and overhead. delorean enables fast recording and parallel replay, but it is based on a non conventional cache coherence protocol that has not yet been implemented. strata uses a recording approach that requires that all processors record an entry in their logs at the same time. rainbow optimizes strata by recording near precise happens before relations, reducing the size of logs and increasing replay parallelism. r relaxed consistency execution to reproduce a dependence graph, the replay phase enforces po one edge at a time. or, such replay is not possible because an access required to happen after another has already been executed. intuitively, pw is a superset of the instructions in reorder buffer, because after a store is retired from the processor, it may stay in the store buffer while being globally performed. dset indicates the instructions that need to be skipped in a region of consecutive dynamic instructions in a processor. pset indicates that the po instructions earlier in. how tor the cycles for ar scheme to handle scv cycles in a dependence graph, all the current so po lutions relax. a relaxed po consistency processor can reorder the instructions in. otherwise, local reordering is observed by remote processors, which may or may not cause scv cycles. therefore, ar scheme supporting relaxed consistency model needs to have three extra components: scv detection detects cycles in recording. scv logging records reordered instructions required to reproduce the scvs during replay. scv replay faithfully reproduces the scvs using the logs generated by scv. depending on the relaxed consistency model supported, differentr schemes may enforce differ po ent types of local reordering of. scv logging scv replay limitations rtr any such load address is invalidated. coreracer when a chunk is logged, the store buffer is not empty. loads in dset are logged as load values, since loads cannot be skipped. for a region, rst execute the instructions in pset and skip the instructions in dset. using data races as the proxies for scv, this has been shown to have false positives; potentially large log size due to the scvfalse positives; cannot handle non atomic writes assumes only one performed point. r schemes supporting tso only need to log and enforce this single type of reordering. the idea is to detect scvs conservatively and remember the values of the potentially sc violating loads. this approach can also be applied to rerun and karma. this can be recorded by logging the load value of and replayed by letting the recorded value overrule the value loaded from memory. coreracer proposes an interesting alternative technique to record the reordered instructions. instead of logging the load values, it uses the simulated store buffer to delay the pending stores. in the record phase, when a processor needs to terminate a chunk and log the instruction count, it checks whether the store buffer is empty, and if it is not, it records the number of pending stores in the store buffer in a counter, rsw. the format of a chunk is, where cs is the chunk size, ts is the timestamp, and type distinguishes whether the chunk is an sc or tso chunk. in the replay phase, rsw and type are used to delay the pending stores for the tso chunks. rc is more relaxed than tso since it allows all kinds of instruction reordering, in particular, the reordering of stores. it uses a history of the generalized form of strata logs to detect scvs. this technique is also used to reduce log size and increase replay speed. when relaxreplay approximately detects an scv, the reordering information is recorded.