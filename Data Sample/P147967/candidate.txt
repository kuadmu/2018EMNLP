in this paper, we present a measurement study of the energy consumption characteristics of three widespread mobile networking technologies: gsm, and wifi. we find that and gsm incur a high tail energy overhead because of lingering in high power states after completing a transfer. based on these measurements, we develop a model for the energy consumed by network activity for each technology. using this model, we develop tailender, a protocol that reduces energy consumption of common mobile applications. we show that the tailender scheduling algorithm is within a factor of the optimal and show that any online algorithm can at best be within a factor of the optimal. for applications like web search that can benefit from prefetching, tailender aggressively prefetches several times more data and improves user specified response times while consuming less energy. we evaluate the benefits of tailender for three different case study applications email, news feeds, and web search based on real user logs and show significant reduction in energy consumption in each case. experiments conducted on the mobile phone show that tailender can download more news feed updates and download search results for more than of web queries, compared to using the default policy. for applications that can tolerate a small delay such asmail, tailender schedules transfers so as to minimize the cumulative energy consumed meeting user specified deadlines. catnap targets data oriented applications, such as web and file transfers, which can afford delay of individual packets as long as the overall transfer times do not increase. catnap exploits high bandwidth wireless interfaces which offer significantly higher bandwidth compared to available bandwidth across the internet by combining small gaps between packets into meaningful sleep intervals, thereby allowing the nic as well as the device to doze off. this results in battery life improvement of up to for real devices like nokia and thinkpad. energy management is a critical issue for mobile devices, with network activity often consuming a significant portion of the total system energy. in this paper, we propose catnap, a system that reduces energy consumption of mobile devices by allowing them to sleep during data transfers. our evaluation shows that for small transfers, catnap allows the nic to sleep for up to of the total transfer time and for larger transfers, it allows the whole device to sleep for a significant fraction of the total transfer time. this allows the middlebox to remain application independent and yet be aware of application requirements, thereby ensuring that delay sensitive packets are di erentiated from delay tolerant packets. this process resembles the functionality of a proxy in acting as a translational functional component, but supports several other functions as we explain later. for lack of a better term we will callita proxy inwhatfollows. this ensures that data continues to ow on the wired segment even if the client is in sleep mode for arbitrary long intervals of time. we conduct a detailed evaluation of catnap using real hardware, under realistic networkconditions. section # presents the detailed evaluation of catnap. we discuss the usability aspects of catnap in section. a well known strategy for saving power is to sleep during idle times. orcommercial advantage and that copies bearthisnoticeand thefull citation onthe rstpage tocopy otherwise, to republish, topost on servers orto redistribute tolists, requiresprior speci. catnap is targeted towards data oriented applications that consumedatain blocks, so combining small idle periods and hence delaying individual packets is acceptable if the data block is delivered on time. application type examples catnap strategy expected bene ts remarks interactive voip none none device and nic remain up to maintain user experience short web transfers software updates. mode time for a mb transfer mode is desirable table #: energy savings with catnap for di erent types of applications. mode is applicable for all mobile devices as the whole device goes into sleep state, consuming negligible power. we have implemented a prototype of catnap as an application independent process at the middlebox. catnap further implements a novel scheduler that schedules adu transmissions on the wireless segment, ensuring maximum sleep time for the clients with little or no impact on the end to end transfer time. energysavingswithcatnap table # gives an overview of catnapbene ts for various applications, also highlighting some of the possible issues with usingcatnap. as we can seefrom thetable, for transfer sizeslarger than kb, catnap canput thenic to sleepfor almost of the total transfer time without anyimpact on user experience. for transfers larger than mb, mode provides signi cant system wide energy savings. we demonstrate using the catnap batch mode that one can manage such a trade. the key design components of catnap include an applicationindependentproxy thatdecouples wired and wireless segments, and a scheduler that operates on adus and attempts to maximize client sleep time without increasing overall adu transfer times. we show howcatnap canimprovebatterylife of tabletpcs and laptops by enabling various sleep modes. our results clearly attest to the promise of catnap to increase mobile client battery lifetime at no to little performance impact. in section #, we present case studies that show how two legacy applicationprotocols can use andbene tfrom catnap. recent work also explores thepossibility of entering low power consuming states in the middle of data transfers. in this paper, we propose catnap, a system that saves energy by combining tiny gaps between packets into meaningful sleep intervals, allowing mobile clients to sleep during datatransfers. a typical example is a home wireless network where. second, it usesanadu as the unit of transfer. third, the middlebox uses bandwidth estimation techniques to calculate the available bandwidth on the wired and wireless links. nic sleep mode targets smaller devices, such as tablets and smart phones, where the nic activity can consume up to of the total energy. ferent contexts but are combined in catnap in a novel way to create sleep opportunities. the schedulercanfurtheroperateintwo modes:onewhereno increase in end to end transfer completion time is allowed, and ii a second one, that we call batch mode. ciency are sometimes at odds in these application scenarios that often involvetransfer of very smallblocks ofdata. for very small transfers by batching multiple objects at the proxy. ciency has always been a critical goal for mobile devices as improved battery lifetime can enhance user experience and productivity. prior permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not madeordistributedforpro. work in this context exploits idleness at various levels, such as sleeping during user think time or when tcp is in slow start. however, deepersleep modes, such as psm orsuspend to ram, are assumed tobe unusable during data transfers when applications are constantly sending data, as entering into these sleep states degrades application performance due to the overhead of using these sleep modes. thesetinygapsarisewhenahighbandwidth access link is bottlenecked by some slow link on the path to the internet. ers much lower bandwidth, typically in the range of mbps. these blocks are often called application data units. first, it decouples the wired segment from the wireless segment, thereby allowing thewireless segmenttoremaininactiveevenwhenthewired segmentis activelytransferringdata. we callthefunctional component separating the wireless and wired segment a middlebox, a capability that could easily be integrated with a home wireless access point. the middlebox will batch packets when the mobile device is sleeping and send them in a burst when the device wakes up. the bandwidth estimates determine the amount of batching required for ontime adu delivery. these concepts have been used in dif note that such capabilitydoes not necessitate theintroduction of a new device, but could easily be supported by other existing devices on the path between the wireless client and its intended wired destination. evaluation numbers correspond to an wireless access network with a mbps wired internet connection. theproxyusestraditionaltransportlayer connection splitting to decouple wired and wireless segments, but supplements os bu ers with extra storage capacity. the scheduler dynamically reschedules transfers if conditions change on the wired or wireless segments, or new requests arrive at the proxy. in this latter case, multiple small objects are batched together at the proxy to form one large object, allowing additional energy savings at the cost of increased delay for individual objects. however, its use is limited to scenarios where the user is not involved in other tasks. our evaluation further demonstrates the ability of catnap to bene. existing application protocols, such as http and imap, without requiring modi cations to servers or clients. contributions the key contributions of this paper are: we design and implement catnap which exploits the bandwidthdiscrepancybetween wireless andwiredlinks toimproveenergy consumptionof mobiledevices. we also consider case studies ofhow existing applicationprotocols, like http and imap, can use and bene. system energy models are important for energy optimization and management in mobile systems. however, existing system energy models are built in a lab setting with the help from a second computer. not only are they labor intensive; but also they do not adequately account for the great diversity in the hardware and usage of mobile systems. moreover, existing system energy models are intended for energy estimation for time intervals of one second or longer; they do not provide the required rate for fine grain use such as per application energy accounting. in this work, we study a self modeling paradigm in which a mobile system automatically generates its energy model without any external assistance. our solution, sesame, leverages the possibility of self power measurement through the smart battery interface and employs a suite of novel techniques to achieve accuracy and rate much higher than that of the smart battery interface. we report the implementation and evaluation of sesame on a laptop and a smartphone. the experiment results show that sesame is able to generate system energy models of accuracy at one estimation per second and of accuracy at one estimation per ms, without any external assistance. two five day field studies with four laptop and four smartphone users further demonstrate the effectiveness, efficiency, and non invasiveness of sesame. in realizing sesame, we answer two technical questions in this work. we evaluate the implementation both in lab and through two five day field studies with four laptop users and four smartphone users, respectively, and compare the generated models against accurate external measurement. an energy model estimates the energy consumption by a mobile system in a given time period. to copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and or a fee. to use the terminology of regression analysis, is the response of the model and, xn are the predictors. most system energy models employ a linear function for. the most important metrics of a model are accuracy and rate, or the reciprocal of the time intervalfor which the energy consumption is modeled. while the importance of high accuracy is obvious, a high rate is also important for many reasons. first, per application energy accounting in a multitasking system requires energy estimation for time intervals of at least ms, or at a rate no lower than hz. per application energy accounting is useful for detecting rogue applications and for incentive mechanisms supporting applications that require a mobile device to consume energy for a goal beyond serving its owner, eg, participatory sensing and cooperative communication. second, energy models are the foundation for energy management and optimization in operating systems and software. existing system energy modeling approaches are however fundamentally limited in two important ways. first, all existing methods except generate the model of a system in the lab using high quality external power measurements. such methods are not only labor intensive but also produce fixed energy models that are determined by the workload used in model construction. modern mobile systems such as smartphones and laptops challenge such methods as will be analyzed in section #. moreover, while cycle accurate hardware power models exist, all reported system energy models except have a low rate. that is, they estimate energy consumption for a time interval of one second or longer. in another word, they estimate energy at a rate of hz or lower. while they work well for certain objectives, eg, thermal analysis management and battery lifetime estimation, energy models of hz are fundamentally inadequate for applications such as per application energy accounting. our approach to address these two limitations of existing methods is to enable a mobile system to construct a high rate system energy model without external assistance. we call this approach self modeling, or sesame. instead of using special circuitry for system power measurement, eg, our key idea to leverage the smart battery interface already available on mobile systems. first, can battery interfaces provide the necessary accuracy and rate for the energy models from hz to hz we report an extensive characterization study of the battery interfaces of existing mobile systems, reveal their fundamental limitations in accuracy and rate, and suggest methods to overcome them. in particular, we leverage the linearity of the energy model and random nature of battery interface error to devise a model molding method that achieves high accuracy and high rate when combined with principal component analysis. second, how can we realize sesame on resource limited mobile devices with improved data collection support and properly scheduled model construction, we show that sesame can be realized with negligible overhead and without affecting normal usage. we implement sesame for both laptop computers and smartphones. the evaluation shows that sesame is able to automatically generate and adapt energy models. for a thinkpad laptop, sesame achieves an accuracy of at hz and at hz, with a battery interface of only hz and without any external assistance; sesame also achieves an accuracy of at hz and at hz for a nokia smartphone with a battery interface only of hz. we show that the model generated by sesame without any external measurement or battery interface knowledge achieves accuracy similar to that of three state of the art system energy models at their intended rates, ie, powertutor at hz, powerbooter at hz, and fsm at hz. moreover, two field studies of four laptop users and four smartphone users show that sesame is able to build energy models without interrupting users. in summary, we make the following research contributions in building sesame. a characterization of battery interfaces on modern mobile devices and their limitations. a suite of techniques to overcome the limitations of battery interfaces and fuel gauge ics for self energy modeling for a rate up to hz. the realization and evaluation of sesame that automatically constructs accurate and fine grain energy models using the battery interface. all model errors reported in this paper except section # are the root mean square of relative errors because it is consistent with the least square method used by linear regression to generate the model. accuracy is calculated as one minus the error. given the same relative error series, the rms of relative errors is never smaller than the average of absolute relative errors used by other work, eg, the rest of the paper is organized as follows. section # discusses related work in system energy modeling. section # provides motivations to the proposed self modeling approach. section # reports our characterization of smart battery interfaces on commercial mobile systems. section # offers the design of sesame and its key technical components in order to address the limitations of the smart battery interfaces and reduce the overhead of self model construction. section # describes the implementation details of sesame. section # evaluates the sesame with both lab and field based studies. sections and discuss the limitations of sesame and conclude the paper, respectively. rssi is known to be a fickle indicator of whether a wireless link will work, for many reasons. this greatly complicates operation because it requires testing and adaptation to find the best rate, transmit power or other parameter that is tuned to boost performance. we show that, for the first time, wireless packet delivery can be accurately predicted for commodity nics from only the channel measurements that they provide. our model uses channel state information measurements as input to an ofdm receiver model we develop by using the concept of effective snr. it is simple, easy to deploy, broadly useful, and accurate. it makes packet delivery predictions for asiso rates and mimo rates, plus choices of transmit power and antennas. we report testbed experiments that show narrow transition regions. we are pleased to announce the release of a tool that records detailed measurements of the wireless channel along with received packet traces. it runs on a commodity nic, and records channel state information based on the standard. unlike receive signal strength indicator values, which merely capture the total power received at the listener, the csi contains information about the channel between sender and receiver at the level of individual data subcarriers, for each pair of transmit and receive antennas. our toolkit uses the intel wifi link wireless nic with antennas. it works on up to date linux operating systems: in our testbed we use ubuntu lts with the kernel. the measurement setup comprises our customized versions of intel close source firmware and open source iwlwifi wireless driver, userspace tools to enable these measurements, access point functionality for controlling both ends of the link, and matlab scripts for data analysis. we are releasing the binary of the modified firmware, and the source code to all the other components. first, it can see the entire program and perform optimizations across procedures that may be in different source modules. in contrast, mapping pro le information back to the source code is more challenging due to the compiler transformations that have been done in between the source code and the executable. we apply these optimizations to ipf linux executables generated by the intelelectron and the gcc compilers. the rest of this paper is organized as follows. post link optimization is a technique to improve the performance of a program after it is compiled and linked. directly operating on the executable has several advantages. second, it is relatively easy to use pro le feedback since the same executable is being pro led and optimized. third, it is applicable even when the program source is unavailable, which may be the case in some commercial or legacy codes. these advantages make post link time optimization appealing, particularly in a production environment. this paper is about post link optimization on the intelitanium processor family processors, under the linux operating system. the ipf architecture provides a number of features that facilitate post link optimization. in particular, its ne grain performance monitoring can identify performance bottlenecks at the instruction level, and software can apply optimizations precisely to remove these bottlenecks. moreover, the rich set of events that can be monitored on ipf enable detailed performance analysis. however, ipf also poses challenges to post link optimizations. speci cally, predication makes post link code transformation in general and branch inversion in particular a challenging task on ipf. we have developed a post link optimization tool called ispike for ipf linux. besides standard optimizations, it implements a number of key optimizations targeting memory latency, including code layout, instruction prefetching, data layout, and data prefetching. they are driven by the branch pro les, cache miss pro les, andcache miss pro les collected via the ipf performance counters. for spec cint, these optimizations improve performance from to on the itanium processor, with average improvement of and over electron and gcc, respectively. we also demonstrate that statistical pro les collected with ipf performance counters provide the same performance bene. first, we describe our pro ling infrastructure in section #. next, we discuss ispike optimizations in section #. we then describe our solutions to a number of ipf implementation issues in section #. we report our experimental results in section #. finally, we relate ispike to other work in section #, and conclude in section #. bit errors occur in wireless communication when interference or noise overcomes the coded and modulated transmission. current wireless protocols may use forward error correction to correct some small number of bit errors, but generally retransmit the whole packet if the fec is insufficient. we observe that current wireless mesh network protocols retransmit a number of packets and that most of these retransmissions end up sending bits that have already been received multiple times, wasting network capacity. to overcome this inefficiency, we develop, implement, and evaluate a partial packet recovery system. ppr incorporates two new ideas: softphy, an expanded physical layer interface that provides phy independent hints to higher layers about the phy confidence in each bit it decodes, and a postamble scheme to recover data even when a packet preamble is corrupted and not decodable at the receiver. finally, we present pp arq, an asynchronous link layer arq protocol built on ppr that allows a receiver to compactly encode a request for retransmission of only those bits in a packet that are likely in error. our experimental results from a node zigbee testbed that includes telos motes with ghz chipcon radios and gnu radio nodes implementing the standard show that pp arq increases end to end capacity by a factor of under moderate load. bit errors over wireless channels occur when the signal to interference and noise ratio is not high enough to decode infor thisworkwas supportedby the national sciencefoundation underaward numbers cns and cns. permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro. or commercial advantage and that copies bear this notice and the full citation on the rst page to copyotherwise, to republish, to post on servers or to redistribute to lists, requires prior speci. in addition to noise, poor sinr arises from the interference causedby oneor more concurrent transmissionsinthe network, and varies in time even within a single packet transmission. thus a tension arises between permitting concurrent transmissions to increase spatial reuse, and receiving those transmissions correctly. even with a variety of physical layer techniques such as spread spectrum and ofdm modulation, channel coding, and the like, current systems rely heavily on link layer retransmissions to recover from bit errors and achieve high capacity. since wireless channels are hard to model and predict, designing an error free communication link generally entails sacri cing signi cant capacity; instead, a design that occasionally causes errors to occurfares betterin this regard. retransmissions allowa receiver to recover from lost packets. retransmitting entire packets works well over wired networks where bit level corruption is rare and a packet loss implies that all the bits of the packet were lost. overradio, however, allthebitsinapacketdon tsharethe samefate: veryoften, onlyasmall numberofbitsinapacketarein error; the rest are correct. thus, it is wasteful to re send the entire packet: our goal is to eliminate this waste. there are several challenges in realizing this goal. ppr incorporates the following two novel techniques, to meet the challenges mentioned above: the softphyinterface allows the receiver to deter mine, with no additional feedback or information from the sender, which bits are likely to be correct in any given packet reception using hints from the phy. thekeyinsight in softphy is that the phy should pass up information about how close each received symbol or codeword was to the symbol or codeword the phy decided upon. the higher layer can then use this information asahint, independent of the underlying details in the phy. postamble decoding allowsareceiverto receiveand decode bits correctly even from packets whose preambles are corrupted by other transmissions or noise. the main idea here is to replicate the information in the preamble and packet header in a postamble and a packet trailer, allowing a receiver to lock on the copyright year#acm. figure #: block diagram of the ppr system; dark blocks and the softphy interface are the contributions of this paper. above one of many different types of receiver structure, modi ed to pass up softphyhints to the maclayer. softphy hints propagate to pp arq, the partial packet retransmission layer, described in section #. postamble and then roll back in time to recover data that was previously impossible to decode. using ppr, we have designed pp arq, a link layer retransmission protocol in which the receiver compactly requests the retransmission of only the select portions of a packet where there are bits likely to be wrong. in response, the sender retransmits the bits and checksums for those ranges, so that the receiver can eventually be certain that all the bits in the packet are correct. the receiver srequest encoding usesadynamic programming algorithm that minimizes the expected bit overhead of communicating this feedback, balancing that against the cost of the sender retransmitting bits already received correctly. wehaveimplemented each of the three aboveideas for, the zigbee standard. our implementation is compatible with that speci cation. the softphy and postamble decoding steps running at the receiver can recover partial packets from unmodi ed zigbee senders, while pp arq requires sender side modi cations for additional insight, we have implemented ppr in an uncoded dqpsk receiver. the underlying premise in ppr is that signi cant performance gains can be obtained by the combination of a more aggressive, higher rate phy and being more exible about the granularity of error recovery in wireless networks. our techniques can improve performance in both access point based networks and wireless mesh networks. section shows severalexperimental results that con rmthis premise: inthat section, we describea nodeindoor testbed consisting of telos motes with ghz zigbee radios from chipcon and six gnu radio nodes. our results showfactorof twogainsoverthe statusquoin aggregate end to end throughput using pp arq. ourgains areeven higher under heavy load, which causes a number of links to have marginal quality. even at light load we nd that onthelinkswiththelowestloss rates, the rawsuccess rate improvesby. we also compare ppr to other ways of determining which bits are likely to be correct, such as fragmented packet checksums. recent work has shown that interfaces are power hungry, so energy management is an important challenge. implementations have additional power states relative to earlier generations of technology, so energy management challenges for are qualitatively different compared to that faced by prior work. in this paper, we describe the design and implementation of snooze, an energy management technique for which uses two novel and inter dependent mechanisms: client micro sleeps and antenna configuration management. in snooze, the apmonitors traffic on the wlan and directs client sleep times and durations as well as antenna configurations, without significantly affecting throughput or delay. increasingly, mobile devices equipped with interfaces are being used for a wide variety of applications including bandwidth intensive hd video streaming. snooze achieves energy savings over cam across workloads ranging from voip and video streaming to file downloads and chats. the capability of mobile devices has increased to the point where a mobile device is often the primary computing device for many people. however, recentwork has shown that nis sig ni cantly power hungry, with power consumption exceed permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro. motivated by this nding, we consider the problem of energy management in devices. energy management for is qualitatively different from that for its predecessor standards. these additional power states motivate us to consider two mechanisms for energy management in simultaneously: micro sleeping which enables the nic to be put into low power sleep state for small intervals of time, and antenna con guration management which dynamically adapts the number of powered rf chains. the design of such mechanisms is challenging because theyare inter dependent: changing the antenna con guration affects airtime of transmissions, which, in turn, affects the sleep opportunities available for nodes in the wlan. like hd video streaming or ledownloads more modestgains are possible by exploiting sleep opportunities at a client when an ap is transmitting to another client, and by selecting the most energy ef cient antenna con guration. snooze adapts client sleep durations and antenna con guration to traf. entering and leaving the wlan, in order to achieve energy savings; this adaptation creates sleep opportunities by shaping traf. while minimally affecting latency sensitive applications, and also takes into account the inter dependence between micro sleeping and antenna con guration. this adaptation is ap directed, application agnostic, works correctly in the presence of rate adaptation, seamlessly incorporates uplink copyright year#acm year#. in section #, we validate these properties using an im table: power consumption forvarious modesof plementation of snooze. we show that it can achieve be intel and atheros nics tween nic energy savings over cam, overa cdf cdf widevarietyof applications ranging fromvoiptohd video streaming, large le downloads and chat. both micro sleeping and antenna con guration management contribute signi cantly to these energy savings, although the proportions they contribute depend on the application. conditionsfor which psm was designed, such as that generated by chat sessions. moreover, snoozenic energy consumption is only higher than that for an ideal energy management scheme in some cases. snoozeenergy savings come at very minimal costs: for le downloads it pays a throughput penalty of relative to cam, and for delay sensitive applications it adds up to ms additional latency on average. finally, snoozecontrol messages consume less than airtime and have the property that the control overhead decreases for high bandwidth applications because snooze leverages frame aggregation. to our knowledge, no other prior work has explored the joint design of micro sleeping and antenna con guration management in the context of wlans, and prior works on ag energy management lack at least one of the properties listed above. as such, mobile devices are being used for bandwidth intensive and or delay sensitive applications, such as hd video streaming andvoip to meet the demands of such applications, mobile devices are being equipped with the latest high speed wireless technology, n. or commercial advantage and that copies bear this notice and the full citation on the rst page. to copyotherwise, to republish, to post on servers or to redistribute to lists, requires prior speci. this is a signi cant concern for mobile devices, whose usability strongly depends upon the lifetime between charges. this is because has additional power states: beyond a low power sleep mode, mimo technology offers the possibility of selectively disabling one or more rf front ends associated with its antennas, thereby saving energy. experiments designed to study the potential bene ts of these two mechanisms reveal several interesting ndings. both micro sleep scheduling and antenna con guration management can provide energy gains which vary with the workload type and extent of background traf. motivated by these ndings, we have designed snooze, a novel energy management system for wlans that has several properties. like voip, exploiting small sleep opportunities during naturally occurring inter packet gaps can provide a four fold reduction in energy usage compared to the always on case. we design sleepwell, a system that achieves energy efficiency by evading network contention. wifi continues to be a prime source of energy consumption in mobile devices. this paper observes that, despite a rich body of research in wifi energy management, there is room for improvement. our key finding is that wifi energy optimizations have conventionally been designed with a single ap in mind. however, network contention among different aps can dramatically increase a client energy consumption. each client may have to keep awake for long durations before its own ap gets a chance to send packets to it. as the ap density increases in the vicinity, the waiting time inflates, resulting in a proportional decrease in battery life. the aps regulate the sleeping window of their clients in a way that different aps are active inactive during non overlapping time windows. the solution is analogous to the common wisdom of going late to office and coming back late, thereby avoiding the rush hours. we implement sleepwell on a testbed of laptops and android phones, and evaluate it over a wide variety of scenarios and traffic patterns. results show a median gain of up to when wifi links are strong; when links are weak and the network density is high, the gains can be even more. we believe sleepwell is a desirable upgrade to wifi systems, especially in light of increasing wifi density. the inability to cope with the energy demands can be serious, and may even hinder the steady growth in the mobile computing industry. this is a judicious design decision, with proven energy bene ts. recently, authors in napman showed the possibility of improvements with psm. the core observation is that multiple clients may wake up after an ap advertisement, and expect to receive their respective burst of packets. through measurements we show that the energy wastage is severe, especially with high device densities in the environment. the main design challenges in sleepwell appear from: distributedly scheduling traf. energy management in mobile devices continues to be a relevant problem. the problem is becoming pronounced, especially with the always connected usage model of modern devices. smartphones, for instance, are rapidly becoming the convergent platform for a large variety of network applications, including emails, music, videos, games, web browsing, and picture sharing. in addition, background applications are continuously running push based alert services, location based noti cations, and periodic sensor updates. is beginning to impose a heavy demand on the phone battery, to the extent that some users are already expressing dissatisfaction. wifi network communication is a predominate source of energy consumption. this has been well known for many years, and a rich body of research has addressed the problems in various ways. for example, wifi power save mode is one of the early protocols that attempts to turn off the device whenever bene cial. while wifi energy ef ciency has progressively improved since psm, we nd that there is still opportunity for improvement. we describe this opportunity by rst describing the core ideas in psm and napman, and then identifying their respective de ciencies. consider the scenario in which a wifi ap intends to communicate to a battery operated mobile client. with wifi psm, the client periodically wakes up to listen to advertisements from the ap. the advertisements include client identi ers for which the ap has queued packets. if a clientlearns that the ap has packets for, it wakes up the entire radio; otherwise, it continues sleeping in the low power state. importantly, waking up the radio incurs a high energy cost, and hence, it is unproductive if the client downloads only a few packets after waking up. therefore, to amortize the wake up cost, psm clients are made to wake up less frequently, permitting multiple packets to queue up at the ap. of course, such queuing introduces latency in psm packet delivery. nevertheless, since a large number of mobile applications are reasonably tolerant to latency, psm correctly takes advantage of it. in current nexus one phones running android, the wifi psm mode wakes up in the orders of ms to download bursts of packets. however, since the ap can transmit one packet at a time, every client must remain awake for a longer duration to receive its packets. this is a source of energy wastage, and napman mitigates this through virtualized aps. brie, the key idea is to make each client believe that it is associated to a different ap, and thus, have their wake up windows staggered over time. the ideas from napman offer energy gains, while also improving the fairness among psm and non psm clients. we observe that napman improves psm in the cases where an isolated ap is connected to multiple clients. in reality, multiple aps are within the wireless vicinity, and this strongly impacts the energy consumption of individual clients. specifically, when a psm client wakes up to download its own burst of packets, it has to share the channel with all other clients of all other aps in the vicinity. in homes or dense of ce areas, it is not unusual to overhear to other aps. since the aps are likely to share the channel fairly between them, it is possible that a client remains awake almost times longer, than it would if there was no contention with other aps. thus, the energy wastage during network activity can be times, and even more if other aps have multiple clients associated to them. we believe that psm and napman can be signi cantly improved if the energy wastage from network contention is alleviated. mitigating network contention from the energy perspective is a relatively unexplored space, especially in the face of emerging applications and usage patterns. sleepwell is tasked to investigate and solve this problem. brie, since aps are always powered on, they monitor ongoing wireless traf. since psm creates periodic bursts of traf, each ap tracks the periodicity of other aps, and dynamically re schedules its own period to minimally overlap with others. reduced overlap reduces competition, allowing each client to download its own packets uninterrupted, and sleep when the channel is occupied by other transmissions. this bears resemblance to a distributed tdma scheme, but executed with energy ef ciency in mind. bursts to achieve quick convergence, ensuring clients do not get disassociated during dynamic rescheduling, and preserving channel utilization, latency, and fairness, even under traf. sleepwell addresses these systematically, while requiring no software changes at the client. by carefully modifying the timestamps, the sleepwell ap regulates the clientsleep and wake up schedules. the client remains unaware of the changes in its own duty cycle; neither does it get disassociated. we have implemented sleepwell on a testbed of laptops and nexus one phones running the android os. performance we rejected a number of involved designs, thereby potentially trading off some performance for standard compliance and scalability. results show that energy reductions vary between to, across a variety of real online applications, including youtube, pandora and last fm internet radio, and tcp bulk data transfer. moreover, as the quality of links degrade, ie, each packet is transmitted at lower bit rates, the relative energy gains improve. in light of these results, we believe that sleepwell may be an effective solution for the future, not only to sustain a demanding suite of applications, but also to improve immunity to increasingly dense wifi environments. our main contributions may be summarized as follows: characterize the problem of network contention and its impact on energy consumption. design a lightweight, standard compatible system running at the ap, that isolates traf. the system requires no changes to the client, and can quickly adapt to changing traf. implement and evaluate the system on a testbed of laptops and android nexus one phone clients. promising performance improvements provide con dence that sleepwell can be an important step towards energy management in wifi enabled mobile devices. the rest of this paper expands on each of these contributions. we motivate the sleepwell design through measurements in section #, followed by the system design in section #. the system implementation and evaluation are presented in section #, while limitations and future work are discussed in section #. section # surveys the related work, and the paper concludes with a brief summary in section #. despite their immense popularity in recent years, smartphones are and will remain severely limited by their battery life. preserving this critical resource has driven smartphone oses to undergo a paradigm shift in power management: by default every component, including the cpu, stays off or in an idle state, unless the app explicitly instructs the os to keep it on such a policy encumbers app developers to explicitly juggle power control apis exported by the os to keep the components on, during their active use by the app and off otherwise. the resulting power encumbered programming unavoidably gives rise to a new class of software energy bugs on smartphones called no sleep bugs, which arise from mis handling power control apis by apps or the framework and result in significant and unexpected battery drainage. this paper makes the first advances towards understanding and automatically detecting software energy bugs on smartphones. it makes the following three contributions: we present the first comprehensive study of real world no sleep energy bug characteristics; we propose the first automatic solution to detect these bugs based on the classic reaching definitions dataflow analysis algorithm; we provide experimental data showing that our tool accurately detected all known instances of no sleep bugs and found new bugs in the apps examined. we thus propose a compile time solution based on the classic reaching de nitions data ow analysis problem to automatically infer the possibility of a no sleep bug in a given app. our implementation handles the speci cs of event driven mobile programming and of the java language such as runtime null pointer exceptions and object references. and they differ from their desktop laptop counterparts in that power consumed by individual io components is often comparable to, or higher than, the power consumed by the cpu. this, along with the fact that smartphones have limited battery life, dictates that energy has become the most critical resource of smartphones. this manipulation is required to ensure the correct operation of the apps. no sleep bugs are de ned as energy bugs resulting from mis handling power control apis in an app or framework, resulting in the smartphone components staying on for an unnecessarily long period of time. no sleep bugs form one important category of the family of smartphone energy bugs which are de ned in as errors in the smartphone system that cause an unexpectedly high energy consumption by the system as a whole. our recent survey has found that of all energy problems in apps and frameworks reported by mobile users were due to no sleep energy bugs. drawing parallels with research on traditional software bugs, a comprehensive treatment of energy bugs on smart phones will require a good understanding of real world energy bug characteristics, learned from common mistakes programmers make in writing smartphone apps, to lead to effective debugging techniques; and developing multi faceted approaches to eliminating energy bugs, including avoiding energy bugs during app development and compile and runtime detection. our contributions this paper takes the rst steps towards understanding and automatically detecting software energy bugs on smartphones. our study reveals a taxonomy of three major causes of nosleep energy bugs, which provide useful guidelines and hints to designing effective detection techniques. our study also con rms the signi cant burden power encumbered programming places on app developers. the tool is capable of running directly on the app installers and hence source code is not required. these include no sleep bugs in many popular apps, eg, the default android email app. motivation smartphones have surpassed desktop machines in sales in year# to become the most prevalent computing platforms. to enrich the user experience, modern day smartphones come with a host of hardware io components embedded in them. the list of components broadly fall into two categories: traditional components such as cpu, wifi nic, radio, memory, screen and storage that are also found in desktop and laptop machines, and exotic components such as gps, camera and various sensors. preserving this crucial resource has driven smartphone oses to resort to a paradigm shift in component power management. on desktop machines, where the cpu accounts for a majority of the energy consumption, the default energy management policy is that the cpu stays on unless an extended period of low load has been observed. the policy is consistent with the historical notion that energy management is a second class citizen since machines are plugged into a power source. smart phones, in sharp contrast, make power management policy. in the idle state, the smartphone as a whole draws near zero power, since nearly all the components, including cpu, are put to sleep. such a sleeping policy is largely responsible for prolonged smartphone standby times smartphones can last dozens of hours when idle. the aggressive sleeping policy, however, severely impacts smartphone apps, since an app may be performing critical tasks by intermittently interacting with the external world using various sensors. for example, an app syncing with a remote server over the network may appear to perform no activity when waiting for the server to send its reply, and the system may be put to sleep by the aggressive sleeping policy, leaving the remote server with a view of lost connectivity. to avoid such disruptions due to the aggressive sleeping policy, smartphone oses provide a set of mechanisms for app developers to explicitly notify the os of their intention to continue using each component. in particular, the os exports explicit power management handles and apis, typically in the form of power wakelocks and acquire and release apis, for use by the app developer to specify when a particular component needs to stay on, or awake, until it is explicitly released from duty. we argue such explicit management of smartphone components by app developers has presented to the app developer a profound paradigm shift in smartphone programming that we call as powerencumbered programming. this new programming paradigm places a signi cant burden on developers to explicitly manipulate the power control apis. consequently, power encumbered programming unavoidably gives rise to a new class of software energy bugs on smartphones, called no sleep bugs. discussions of energy bugs on numerous internet forums have narrowed the causes to mis handling of power control apis by apps and the framework on smartphones oses, including android, ios, and windows mobile. these and other types of energy bugs have caused a great deal of user frustrations. despite their severity, ie, high battery drain, to the best of our knowledge there has been no study of any kind of smart phone energy bugs, much less no sleep energy bugs. speci cally, our paper makes three concrete contributions: the rst characterization study of no sleep energy bugs in smartphone apps: we present the rst comprehensive real world no sleep energy bug characterization study. our study is based on no sleep energy bugs in real world apps and the android frame in this paper, we use the term framework to refer to both the services in and the apps that are bundled with, the android framework. work, including popular apps and built in apps and services. the bugs are collected by crawling internet mobile forums, bug repositories, commit logs of open source android apps and by running our no sleep bug detector developed in this paper. for each bug, we carefully examine its reported symptoms, corresponding source code and related patches, and developerdiscussions, or the analysis performed by our bug detector. our solution detects no sleep bugs in single threaded and multi threaded apps, as well as event based apps which have multiple entry points. like all static analysis based tools, our detection tool can suffer false positives but has the tremendous advantage of no runtime overhead and no false negatives. we further present the complete implementation of our static analysis detection tool for apps written for android. detecting new no sleep bugs in android apps and framework: we have run our no sleep bug detection tool on android apps and the framework collected from the android market. experimental evaluation shows that our tool accurately detected all reported instances of no sleep bugs, as well as instances of new previously unreported no sleep bugs. our nosleep bug detection incurred false positives in out of the apps it reported to contain a bug. this paper describes a bus mastering implementation of the pci express protocol using a xilinx fpga. source code is offered for free download via the web. while the theoretical peak performance of pci express is quite high, attaining that performance is a complex endeavor on top of an already complex protocol. the implementation is described and its performance is analyzed. the fundamental problem is that, all such algorithms are mimo oblivious; they do not consider the characteristics of diversity oriented, single stream mode and the spatial multiplexing driven, double stream mode. this paper studies mimo based rate adaptation in wireless networks. our case study shows that existing ra algorithms offer much lower throughput than even a fixed rate scheme. we propose mira, a novel mimo ra scheme that zigzags between intra and inter mode rate options. our experiments show that mira consistently outperforms three representative ra algorithms, samplerate, rraa and atheros mimo ra, in static, mobility and collision settings. with multiple transmit and multiple receive antennas and channel bonding, the standard allows for two operation modes. the other is the spatial multiplexing driven, double stream mode. using both ss and permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro. or commercial advantage and that copies bear this notice and the full citation on the rst page. to copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci. in this paper, we identify issues and propose solutions for mimo based ra in systems. our extensive experiments further discovered that there exhibits a non negligible, non monotonic relation between loss and rate in mimo scenarios, when considering all rate options and ignoring operation modes. in this paper, we design, implement and evaluate mira, a new ra algorithm for mimo systems. rate adaptation in the recent ieee systems dynamically adjusts the modulation coding scheme based on the runtime channel quality. it is critical to network throughput, yet unspeci ed by the standard. what makes ra in the setting di erent from the legacy ag systems is its new multiple input multiple output technology. one is the diversity oriented single stream mode. ers a wide range of rate options, starting from mbps and reaching mbps at the maximum. mimo ra is likely to be important in systems due to the wider span and larger number of rate options. our work started from a case study of existing ra algorithms using prototypes and experiments on standard compliant ap platform. the case study asked a simple question: can we simply apply these ra algorithms, which have been shown to work well for the legacy ag networks, to the mimo setting to this end, we chose two representative ra algorithms: rraa, and samplerate. we also evaluated another algorithm, atheros mimo ra, used in atheros chipsets. to our surprise, all three algorithms did not do well,ering to lower goodput, de ned as. ective throughput by excluding protocol overhead, than the best xed rate scheme. the fundamental problem is that, all such algorithms do not properly consider ss and ds modes, thus not exploiting the inherent mimo characteristics, which exhibit very di erent loss patterns across ss and ds modes. as the rate value increases, loss does not monotonically grow with rates in di erent modes. a higher rate may consequently lead to lower loss and larger goodput. this is the reason why existing ra algorithms got stuck at lower rates that yield much smaller goodput. however, the good news is that within each ss ds mode, the monotonic behavior between loss and rate still largely holds. mira uses a novel zigzag ra scheme, which opportunistically zigzags between intra mode ra and inter mode operations. when performing rate update, it rst retains its current ss ds mode but adapts the rate upward downward. this intramode ra exploits the monotonicity between loss and rate in the same mode. when it cannot further improve goodput in its current mode, mira performs inter mode ra by exploring the other ds ss mode. mira further uses prioritized, adaptive probing to reduce the penalty incurred by probing bad rates and swiftly identify the best rate. finally, mira exploits features of frame aggregation and blockack in to detect collisions from channel errors. our experiments in both controlled testbed settings and eld trials con rm the performance gain of mira in all cases of fading, hidden terminal induced collisions, and mobility. our experiments show that mira outperforms all three ra algorithms with goodput gains up to in static settings, for mobile clients, and up to year# in intense interference scenarios. in the eld trials, mira achieves goodput gains from up to over the three existing algorithms. the rest of this paper is organized as follows. section # introduces the background, and describes our experimental setting. section # studies a simple case of applying existing ra algorithms in the scenario, and section # reports the ndings on characteristics of ss and ds modes. section # presents the design of mira, and section # describes its implementation and evaluation. wifi radios in smart phones consume a significant amount of power when active. the standard allows these devices to save power through an energy conserving power save mode. however, depending on the psm implementation strategies used by the clients access points, we find competing background traffic results in one or more of the following negative consequences: a significant increase, up to, in a client energy consumption, a decrease in wireless network capacity due to unnecessary retransmissions, and unfairness. in this paper, we propose napman: network assisted power management for wifi devices that addresses the above issues. napman leverages ap virtualization and a new energy aware fair scheduling algorithm to minimize client energy consumption and unnecessary retransmissions, while ensuring fairness among competing traffic. napman is incrementally deployable via software updates to the ap and does not require any changes to the protocol or the mobile clients. our prototype implementation improves the energy savings on a smart phone by up to under varied settings of background traffic, while ensuring fairness. thus, optimizingwifipower consumptionis essentialfor maximizing the batterylife ofmobile smart phones. in orderto minimize energyconsumptioninwifidevices, napman solvestwokey challenges: isolation ofpsm clientsfrom competing a cam traf. innapman, the ap advertises the presence of buffered packets for the psm clientinthe upcomingbeacon onlyifhighpriority scheduling of at leastonebufferedpacket ofthepsmclientdoesnot skip ahead of anypacket thathasbeen waitinglongerin the transmitqueue. un likeapimplementationstoday, the scheduler continuesto maintain aqueue ofbufferedpacketsfor adaptive psm clients and manages theirpacketdelivery carefully. whilethefair schedulingapproachhelpsisolatepsmfromcam traf, thepresence of multiplepsm clientsassociated with asingleapisstillproblematic sincethepsm clientsmay need tostay awake while otherpsm clients arebeing served. wireless communication imposes a signi cant energy cost on mobile smart phones. for example, the base energy consumption of the htc tilt series phone ranges between mw, depending on the intensity of the backlight. in comparison, the wifi radio consumes over year#mw while transmitting. wifiradios supportpower saving mechanismsbyimplementing multiple modes of operation withdifferentpower andperformance characteristics. for example, thetilt swifi radioactive orconstantlyawakemode drawshighpower anddelivers low latency, while the radio in sleep or power save mode consumeslittlepower atthe cost ofincreasedlatency. ieee static and adaptive psm mechanisms and related researchliterature include anumber oftechniquesforleveragingpsmin orderto saveenergy. in these approaches, the accesspoint supportspsmby buffering incomingpackets forwifi clientsinpsm, indicating thepresenceofbufferedpacketsvia eldsinbeaconmessages, and delivering the buffered packets after the client noti es the apitready to receive one or morepackets. this allows thewifi radio to spend most of the time in low power psm, waking up to highpowercam onlyin order to receiveitsintendedpackets. however, depending on thepsmimplementation strategies used by theapsand theclients, we nd through controlled experiments that competingbackground traf. resultsin one or more of thefollowing negativeconsequences: asigni cantincreaseintheclientenergy consumption, a decrease in wireless network capacity due tounnecessary retransmissions, andunfairness. furthermore, our network trace analysis indicates that such situations arelikelyquite commonduringpeak usage. in this paper, we present napman, a network assisted power managementsolutionthat minimizeswifienergy consumptionfor mobiledevices, eveninthepresence of competingtraf c. napman implements a new energy aware fair scheduling algorithm at the ap that minimizes wifi radio wakeup time and eliminates unnecessary retransmissionsinthepresence ofcompetingtraf c. further, napmanleveragesapvirtualizationin a novel manner in order to isolatepsmclientsfrom each other. finally, napmanisincrementally deployable since it requires only software updates to the ap no changes are needed to ieee standards or the wifi devices smart phones. let us rst consider the problem of competing cam traf c. through controlled experiments, wefounddifferent commercialapsimplementdifferent scheduling strategieswhenapsm client wakesup and noti es its ap. many implementations simply perform normal scheduling that enqueues all buffered packets of a psm client to the tail of the transmitqueue. this increases the time psm clients remain in high power cam, wasting energy, while packets that were ahead in the queue are being transmitted. to deal with this issue, different phones implement different psm strategies. for example, phones such as the iphone gs use adaptive psm with aggressive timeout values of ms. when these clients encounter aps that use normal scheduling, the net effect is the client sleeps quickly whileitspsmpacketsinthetransmitqueue end up being retransmitted multipletimes whenthese losses arecoupled with rate adaptation, they resultin signi cant waste of network capacity. other commercialapsimplementa highprioritysolution for psm clients, whereby they simply enqueue the buffered psmpackets to ahigherpriorityqueue. while this approach helps save energy when onepsm clientis competing withcam clients, we show such a simplistic approach can resultin signi cant unfairness to othercam clients. thenapman energy awarefair scheduler aimstodeliver energy savings without unfairness. a simple fairness policy is to deliver packets based on the order of arrival, in. however, fcfs policy turns out to be non work conserving, aspacketsdestined topsm clients cannotbedelivered until the client wakes up. thenapman scheduler enforces a workconservingfcfspolicy where thefcfs constraintis applied only topackets of clients that are awake at anygiven time. these mechanisms allowboth static and adaptive psm clients to quickly go back to sleep, saving energy. interestingly, we nd the napman scheduler not only saves energy, but also reduces latency compared to normal scheduling since addingpsmpackets to thetail of thequeue tendstobe unfair topsm clients. in this case, both normal and high priority scheduling result in increased client energy consumption. instead, napman relies on a novel solution that leverages virtualization. thenapmanapadvertises severalvirtual aps through beacons that are staggered in time. the psm clients are then made to associate to the appropriate virtual ap, thereby isolatingpsm clientsfrom each other. we have implemented the napman scheduling and virtualization mechanismsinthemadwi driver. through extensive experiments under a varietyoftraf cconditions, we show that napman delivers energy savings similar to or better thanthehighpriority solution, avoids unnecessary retransmissions, and enforcesfairnessforbothpsm andcam clients. finally, for completeness, we design an extension to napman that is able to take advantage of simple changes on the clients in order toprovidefurther energy andlatencybene ts. in summary, the contributions of thepaper are asfollows: through controlled experiments and wireless network trace analysis, we showthat currentap and clientpsmimplementations can negatively impact energy consumption, network capacity, and orfairnessinthepresence of competing traf c. we present the design and implementation of napman, an ap based incrementally deployable solution that utilizes a new energy aware fair scheduling algorithm and leverages virtualization to minimize energy consumption and unnecessary retransmissions for static adaptive psm clients while maintainingfairness. using extensive experiments, we show that napmanis able todeliver signi cant energy savings of up to compared to current ap implementations for various network traf. to address this problem, we introduce turborate, a rate adaptation scheme for mu mimo lans. turborate shows that clients in a mu mimo lan can adapt their bit rate on a per packet basis if each client learns two variables: its snr when it transmits alone to the access point, and the direction along which its signal is received at the ap. turborate also shows that each client can compute these two variables passively without exchanging control frames with the access point. a turborate client then annotates its packets with these variables to enable other clients to pick the optimal bit rate and transmit concurrently to the ap. a prototype implementation in usrp shows that traditional rate adaptation does not deliver the gains of mu mimo wlans, and can interact negatively with mu mimo, leading to low throughput. in contrast, enabling mu mimo with turborate provides a mean throughput gain of and, for antenna and antenna aps respectively. in multiuser mimo networks, the optimal bit rate of a user is highly dynamic and changes from one packet to the next. this breaks traditional bit rate adaptation algorithms, which rely on recent history to predict the best bit rate for the next packet. wireless lans are facing two trends: first, the number of antennas on an access point is increasing steadily, with typical aps today having two or three antennas. second, there is a proliferation of small wifi devices, eg, sensors, smart phones, and game consoles, which have a small form factor and strict power limitations, and hence typically use a single antenna. these trends cause a multi antenna access point to spend a signi cant fraction of its time communicating with a single antenna client. as a result, wireless lans will not deliver the maximum number of concurrent transmissions enabled by their infrastructure. to address this problem, researchers have advocated the use of multiuser mimo permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro. or commercial advantage and that copies bear this notice and the full citation on the rst page. to copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci. red client sends concurrently snr after projection with blue client changes red client sends concurrently snr after projection with green client is larger than in figure # optimal bitrate changes after projection. the smaller angle between the concurrent clients leads to a larger amount of snr reduction after projection. lans, where multiple single antenna clients communicate concurrently with a multi antenna ap. they demonstrated that decoding such concurrent transmissions is feasible both on the uplink and downlink. they also developed a mac pro tocol that allows clients to contend for concurrent transmissions to a multi antenna ap. so far, however, research on mu mimo wlans has not addressed the bit rate selection problem, and simply assumed that the transmitters know the best bit rate. this assumption is valid on the downlink where there is only one transmitter, the ap, and hence the problem can be reduced to standard rate adaptation. to see the problem, consider the scenario in figure # where two single antenna clients transmit concurrently to a antenna access point. recall that a antenna ap receives signals in a dimensional space de ned by its two antennas, as shown in figure #. the basic approach for decoding the concurrent packets is as follows: the ap rst projects the incoming signal on a direction orthogonal to one of the clients, say the blue client. this eliminates the signal of the blue client and allows the ap to decode the red client. note that the success of this decoding process depends on the ap being able to decode the red client after projecting its signal on a direction orthogonal to the blue client. this projection however reduces the snr of the red client, as evident from the reduction in the length of the projected red vector in figure #. this means that the red client should transmit at a bit rate supported by its snr after projection; otherwise the ap becomes unable to decode its signal. note also that the snr after projection and hence the optimal bit rate depends on the angle between the signals of the two clients, ie, for example, if the red client transmits its next packet with the green client, as in figure #, then its snr after projecting on a direc tion orthogonal to the green client will be different, as in figure #, and hence the red clientoptimal bit rate for the next packet will change. thus, in a mu mimo lan, the optimal bit rate of a client changes depending on the set of clients that transmit with it. this paper presents turborate, a bit rate adaptation protocol suitable for concurrent mu mimo clients. turborate enables a mu mimo client to pick the optimal bit rate for each packet it transmits, even when the bit rate changes from one packet to the next. at a high level, turborate works as follows. each client listens to the aptransmissions to learn the channel coef cients from the ap to itself. the client uses this information to passively compute two variables: the direction along which the ap receives its signal, and its snr if it were to transmit to the ap alone. a client that wants to transmit concurrently with the rst client uses this information to project its signal orthogonal to the rst client and compute the reduction in its snr. additional concurrent clients can join the transmission and compute their optimal bit rate using the same process. a notable feature of turborate is that it works in a distributed random access manner. speci cally, a client, eg, the blue client in figure #, can win the contention and transmit, picking its bit rate as usual without knowing whether other clients have packets and may transmit concurrently. a client, like the red client, that decides to transmit concurrently with the rst client does not have to confer note that the direction along which an ap receives a clientsignal stays stable with the channels, despite that the signal rotates in the complexq plane. this is because this direction is expressed in the ap antenna space, not in theq plane. we built a prototype of turborate using the usrp radio platform and evaluated it over a mhz channel. our implementation uses an ofdm phy layer and supports the various modulations and coding options used in. our results are as follows: activating mu mimo with existing bit rate selection fails to deliver its gains and can lead to a signi cant throughput reduction. in particular, we experimented with different client positions that span the range of inter client reception angle, ie, the results show that, in of the studied cases, enabling mu mimo without addressing its special needs for per packet bit rate adaptation reduces the throughput below that achieved with a single client. further, in about of the cases, the network throughput reduces to zero because the clients rates overshoot the capacity of the network. turboratebit rate selection enables mu mimo to deliver its gains. with turborate, mu mimo produces an average throughput gain of in the case of antenna ap and in the case of antenna ap. turborate enables distributed bitrate adaptation for mu mimo lans. the closest to our work is, which supports per packet bit rates, but addresses a different problem in which concurrent clients communicate with different aps. it also assumes that concurrent clients have a different and increasing number of antennas. in contrast, turborate can support clients, with the same or different numbers of antennas, transmitting to an ap in a mu mimo lan. the optimal bitrate depends on the client that is transmitting concurrently. the scenario on the uplink, however, is quite different: it has multiple concurrently transmitting clients that collectively have to pick the best bit rates to their ap. the decisions made by these clients are not independent; they interact in a complex manner that intrinsically differs from existing networks. the ap then uses interference cancellation to subtract the red clientsignal and decode the blue client. since this set may vary from one packet to the next, the optimal bit rate changes on a per packet basis. this breaks the basic assumption underlying existing bit rate adaptation algorithms, which use the bit rate that ts recent packets as a predictor for the best bit rate for the next packet. it then maps its snr after projection to the optimal bit rates using standard snrbitrate tables. with it; it simply picks a bit rate that does not interfere with the rst clientreception. rate adaptation is a mechanism unspecified by the standards, yet critical to the system performance by exploiting the multi rate capability at the physical layer. this paper, we conduct a systematic and experimental study on rate adaptation over wireless networks. first, we critique five design guidelines adopted by most existing algorithms. our study reveals that these seemingly correct guidelines can be misleading in practice, thus incur significant performance penalty in certain scenarios. the fundamental challenge is that rate adaptation must accurately estimate the channel condition despite the presence of various dynamics caused by fading, mobility and hidden terminals. second, we design and implement a new robust rate adaptation algorithm that addresses the above challenge. rraa uses short term loss ratio to opportunistically guide its rate change decisions, and an adaptive rts filter to prevent collision losses from triggering rate decrease. our extensive experiments have shown that rraa outperforms three well known rate adaptation solutions in all tested scenarios, with throughput improvement up to. rate adaptation is a link layer mechanism critical to the system performance in ieee based wireless networks, yet left unspeci ed by the standards. the current speci cations mandate multiple transmission rates at the physical layer that use di erent modulation and coding schemes. for example, the phy supports four transmission rates, the a phy offers eight rates, and the phy sup permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro. or commercial advantage and that copies bear this notice and the full citation on the rst page. to copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci. to exploit such multi rate capability, a sender must select the best transmission rate and dynamically adapt its decision to the time varying and location dependent channel quality, without explicit information feedback from the receiver. such an operation is known as rate adaptation. given the large numerical span among the available rate options, rate adaptation plays a critical role on the overall system performance in based wireless networks, such as the widely deployed wlans and the emerging mesh networks. in recent years, a number of algorithms for rate adaptation have been proposed in the literature, and some have been used in real products. their basic idea is to estimate the channel quality and adjust the transmission rate accordingly. this is typically achieved by using a few metrics collected at the sender and the associated design rules. the widely used metrics include probe packets, consecutive successes losses, phy metrics such as snr, and long term statistics. examples of the commonly used rules include increasing rate upon consecutive successes, using probe packets to assess new rates, etc. while all such metrics and rules seem intuitively correct and each design has its own merits, little is known about how. the fundamental problem is that real world wireless networks exhibit rich channel dynamics including random channel errors, mobility induced channel variation, and contention from hidden stations. each of the above metrics and associated design rules has limited applicable scenarios. in this paper, we conduct a systematic and experimental study to expose the challenges for rate adaptation and explore new design space. to this end, we rst use experiments and simple analysis to critically examine ve design guidelines followed by most existing algorithms. these guidelines include: decrease transmission rate upon severe packet loss, use probe packets to assess the new rate, use consecutive transmission successes losses to decide rate increase decrease, use phy metrics to infer new transmission rate, and long term smoothened operation produces best average performance. for experimental comparison, we implement three popular algorithms on a programmable ap platform, together with the onoe algorithm available in madwifi. we not only identify the issues with these algorithms using experiments, but also take a microscopic view of their runtime behavior and gain insights on the root causes of the issues. our experiments surprisingly show that the above copyright year# acm. figure #: experimental oor plan ve seemingly valid guidelines can be quite misleading in practice, and may incur signi cant performance penalty of up to throughput drop. in fact, we even discovered that with mild link layer contention, these rate adaptation designs not only fail to facilitate throughput improvement, but also reduce the throughput and aggravate channel contention because rate decrease is falsely triggered. to address these challenges, we design and implement a robust rate adaptation algorithm based on two novel ideas. first, we use short term loss ratio in a window of tens of frames to opportunistically guide the rate selection. such a loss ratio provides not only fresh but also dependable information to estimate the channel quality. second, we leverage the per frame rts option in the standards, and use an adaptive rts lter to suppress collision losses with minimal overhead. we implement rraa on a programmable ap platform and evaluate its performance using thorough experiments as well as eld trials. our results show that rraa consistently outperforms three well known algorithms of arf, aarf and samplerate in all scenarios with achannels, static mobile stations, tcp udp ows, with without hidden stations, and in controlled uncontrolled environments. the throughput improvement of rraa over these algorithms can be as high as in realistic eld trials. the two key contributions of this paper are as follows. first, we provide a systematic critique on ve design guidelines in the state of art rate adaptation algorithms. second, we design, implement and evaluate a robust rate adaptation algorithm, which addresses all these identi ed issues and is fully compliant with the standards. the rest of the paper is organized as follows. section # introduces the background and section # describes our experimental system and methodology. section # examines ve design guidelines in existing rate adaptation algorithms. section # presents the design of our robust rate adaptation algorithm, and section # describes the implementation and evaluates its performance. section # discusses the related work, and section # concludes the paper. wifi interface is known to be a primary energy consumer in mobile devices, and idle listening is the dominant source of energy consumption in wifi. most existing protocols, such as the power saving mode, attempt to reduce the time spent in il by sleep scheduling. to remedy this problem, we proposemili that reduces the power consumption in il, given that the time spent in il has already been optimized by sleep scheduling. mili incorporates sampling rate invariant detection, ensuring accurate packet detection and address filtering even when the receiver sampling clock rate is much lower than the signal bandwidth. our experimental evaluation shows thatmili can detect packets with close to accuracy even with downclocking by a factor of. when integrated with, mili can reduce energy consumption by around for of users in real world wireless networks. however, through an extensive analysis of real world traffic, we found more than of energy is consumed in il, even with psm enabled. observing that radio power consumption decreases proportionally to its clock rate, mili adaptively downclocks the radio during il, and reverts to full clock rate when an incoming packet is detected or a packet has to be transmitted. further, it employs an opportunistic downclocking mechanism to optimize the efficiency of switching clock rate, based on a simple interface to existing mac layer scheduling protocols. we have implementedmili on the usrp software radio platform. continuing advances of physical layer technologies have enabled wifi to support high data rates at low cost and hence become widely deployed in networking infrastructures and mobile devices, such as laptops, smartphones, and tablet pcs. despite its high performance and inexpensive availability, the energy ef ciency of wifi remains a challenging problem. for instance, wifi accounts for more than of the energy consumption in current laptops. it may also raise a smartphonepower consumption times even without packet transmissions. wifienergy inef ciency comes from its intrinsic csma mechanism the radio must perform idle listening continuously, in order to detect unpredictably arriving packets or assess a clear channel. the energy consumption of il, unfortunately, is comparable to that of active transmission reception. even worse, wifi clients tend to spend a large fraction of time in il, due to mac level contention and network level delay. therefore, minimizing the ilenergy consumption is crucial to wifienergy ef ciency. a natural way to reduce the ilenergy cost is sleep scheduling. the ap buffers downlink packets and transmits only after the client wakes up. however, it cannot reduce the il time associated with carrier sensing and contention. since the il time cannot be reduced any further due to wificsma, we exploit an additional dimension reducing il power consumption in order to minimize its energy cost. theoretically, by reducing clock rate alone, mili reduces the ilpower consumption linearly. it is, however, nontrivial to ensure that packets can be received at a lower clock rate than required. to decode a packet, the receiversampling clock rate needs to be at least twice the bandwidth of the transmitted signal, following the nyquisttheorem. wifi radios have already been optimized under this theorem by matching the receiverclock rate with the nyquist rate. mili meets this challenge via a novel approach called sampling rate invariant detection. srid separates the detection from the decoding of a packet. upon detecting this special preamble, the receiver immediately switches to the full clock rate and then recovers the packet with a legacy decoder. mili allows srid to be integrated into existing mac or sleeping scheduling protocols, using a simple opportunistic downclocking scheme. traces, we nd that for the majority of clients, the overall energy saving withmili is close to that in pure il mode with the maximum downclocking factor. according to our measurements, this corresponds to for a typical wifi card with a downclocking factor of, and for a software radio with a downclocking factor of. further, our packet level simulation results show thatmili reduces energy consumption consistently across different traf. in summary, this paper makes the following contributions. exploration of the feasibility and cost of ne grained control of radio clock rate to improve energy ef ciency. introduction of odoc, a generic approach to integrating srid with existing mac and sleep scheduling protocols. the remainder of this paper is organized as follows. analyzes the energy cost of il in wifi networks and describes the motivation behindmili. presents a measurement study of the relation between energy consumption and clock rate in wifi and software radio devices. and present the detailed design of srid and odoc, respectively. in wifipower saving mode and its variants, clients can sleep adaptively, and wake up only when they intend to transmit, or expect to receive packets. by aggregating downlink packets, thereby reducing the receiverwait time caused by the network level latency. through an extensive trace based analysis of real wifi networks, we have found that il still dominates the clients energy consumption even with psm enabled: it accounts for more than of energy consumption for clients in a busy network and in a relatively idle network. ideally, if the exact idle period is known, the radio could be powered off or put to sleep during il, and wake up and process packets on demand. however, due to the distributed nature of csma, the idle time between packets varies widely and unpredictably. under estimation of an idle interval will waste energy, while an over estimation causes the radio to drop all incoming packets during the sleep. so, one may raise an important question: is it possible to put the radio in a subconscious mode, where it consumes little power and can still respond to incoming packets promptly we answer this question by proposing energy miminizing idle listening that reduces the clock rate of the radio during its il period. the power consumption of digital devices is known to be proportional to their voltage square and clock rate. it adds a special preamble to each packet, and incorporates a linear time algorithm that can accurately detect the preamble even if the receiverclock rate is much lower than the transmitter. srid embeds the destination address into the preamble, so that a receiver may only respond to packets destined for it. odoc enables ne grained, packet level power management by adding a downclocked il mode into the radiostate machine. odoc exploits the burstiness and correlation structure of real traf. of downclocking, and then downclocks the radio only if it is unlikely to incur signi cant overhead. we have implemented anmili prototype on the gnura dio usrp platform. our experimental evaluation shows thatmili can detect packets with close to accuracy even if the radio operates at of the normal clock rate. within a normal snr range, mili performs comparably to a legacy detector. design of srid, a novel packet detection algorithm that makes it possible to detect packets even if the receivers are downclocked signi cantly. implementation ofmili on a software radio platform and validation of its performance with real traces and synthetic traf c.