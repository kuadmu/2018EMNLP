memory safety ofis a well researched area and can be categorized into software based approaches and hardwarebased approaches. managedc is a software based approach, thus we focus on research in this area rather than on hardwarebased research such as. finally, we discuss the boehm demers weiser gc, which provides temporal safeness. a survey of related work to interpretation ofcode can be found in. pointer based approaches our technique is inspired by pointer based metadata approaches: pointer based approaches store year# year# year# year# year# year# year# year# year# year# gcc gcc best truf ec managedc figure #: performance numbers of truf ec and managedc, relative to gcc. additional information for each pointer of aprogram so that pointers become multi word values that hold the actual pointer value along with metadata. pointer arithmetic then modi es the actual pointer value, but the metadata remains unchanged. when a pointer is dereferenced, the actual pointer value is checked against the bounds of the object, which ensures spatial safety. these capabilities stay in existence even after the deallocation of an object, which allows checking the pointervalidity when it is dereferenced. safec allows the detection of spatial and temporal memory errors by using fat pointers that encode the pointer value, base and size information, a storage class, and a capability to the referent. ccured classi es pointers in three categories: safe pointers, which cannot be used for pointer arithmetic, array indexing or type casts and cause almost no run time overhead; seq pointers, which are fat pointers that allow pointer arithmetic, array indexing and primitive casts; and wild pointers, which support arbitrary casts but have additional metadata and require run time checks. nagarakatte et al describe softbound and cets, which use compile time transformations for detecting spatial and temporal safety violations. they report an average run time overhead of. an maddress object can be seen as a fat pointer and the memory management of the jvm ensures temporal safety. the novelty in our approach is that we transferred the idea of fat pointers to ainterpreter, which is implemented in java. it uses a dynamic compiler and a sophisticated automated memory management. this allows us to ensure spatial and temporal safety with little effort: we use a layout to map the offset of an maddress to the corresponding member of a managed allocation and eventually do a java member access, which ensures spatial safety. the deallocation of the object itself is then done by the gc of the jvm. object based approaches object based approaches track information about each object such as its status or its bounds and stores it in an auxiliary data structure. spatial and temporal safety is ensured by map ping pointer values to the tracked information and by checking that pointer arithmetic and pointer dereferencing fall within the bounds of the object. jones and kelly report an overhead of compared to gcc performance. purify traps every memory access by instrumenting the object code of a program and by allocating red zones before and after each allocation. eiglermud ap system inserts an additional pass into gccs normal compilation to instrument thecode and to assert a validity predicate at every use of a pointer. mud ap caches the lookup in the auxiliary data structure and has an average run time overhead of compared to unsafe execution. ne grained partitioning of memory to provide run time bounds checking for arrays and strings. ruwase and lam prevent buffer over ows by intro ducing out of bound objects for all out of bound pointers. any pointer derived from an out of bound object is boundchecked before it can be dereferenced. they report a runtime overhead in the range of. boehm demers weiser gc the boehm demers weiss gc is a conservative gc forandthat can provide temporal safeness. however, the architecture of the two approaches is different: managedc executescode on a memory safe runtime via ast interpretation. like existing literature surveys, we distinguish between pointer based approaches and object based approaches. to ensure temporal safety, every allocated object gets a unique identi er. the run time checks introduced by safec cause a run time overhead between and. ccured programs have an overhead in the range of to. these approaches keep the metadata in a separate metadata space, which retains memory layout compatibility. we mark freed objects as deallocated, which allows us to ensure temporal safety. also, our approach is source compatible with regularprograms and does not require any changes in them because we mimic the behavior of industry standardcompilers. we dynamically compile managedc asts with a state of the art dynamic compiler, which is very good at removing access bounds checks or moving them out of hot loops. after an initial warm up and dynamic compilation of the ast we can report an average overhead of compared to programs that are compiled with the best possible optimization level of gcc. they report a run time overhead of compared to the gcc performance. they report an overhead of compared to an unchecked execution. our system represents pointer values by maddress objects that use a java reference to refer to the allocation. we detect spatial memory errors when the offset of the maddress object cannot be mapped to a member of the referent and temporal errors when the referent is not allocated or the referent is marked as deallocated. hence, we consider our approach as distinct from objectbased approaches. it uses a mark sweep algorithm and provides incremental and generational collection. it works with unmodi edprograms by replacing native memory allocations with gc allocations and removing free calls completely. also, it can run in a leak detection mode that allows ensuring temporal safety. like managedc, this approach automatically deallocates memory that is not used anymore. it introduces maddress objects to represent pointers and allocates managed objects, which allows reusing the gc of the runtime without additional effort.